package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;


parser code {:

	// counting declarations vars
	int globalPrimitiveVarsCount = 0;
	int globalArraysCount = 0;

    // counting definitions vars
	int globalFunctionsCount = 0;
	int innerClassesCount = 0;

    //
	int statementsCount = 0;
	int functionCallsInMainCount = 0;
	int objectCreationCount = 0;

	// inner classes vars
	int innerClassAttributesCount = 0;
	int innerClassMethodsCount = 0;
	int extendingClassesCount = 0;


	// error detection var
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        //report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

    /*
     * util functions
     */

    public void constantProcessing(String id, int idleft, Struct type, ConstNode node){

        Obj konstanta = Tab.find(id);

        if (konstanta.equals(Tab.noObj)) {

            switch(node){
                case NUMBER:

                    if(Tab.intType.equals(type)){

                       konstanta = Tab.insert(Obj.Con, id, type);
                       report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                    }else {
                       report_error("Semanticka greska [2S-03] na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije int", null);
                    }
                    break;

                case CHAR:

                        if(Tab.charType.equals(type)){

                           konstanta = Tab.insert(Obj.Con, id, type);
                           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                        }else {
                           report_error("Semanticka greska [2S-04] na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije char", null);
                        }
                    break;

                case BOOL:

                        if(TabUtils.boolType.equals(type)){

                           konstanta = Tab.insert(Obj.Con, id, type);
                           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                        }else {
                           report_error("Semanticka greska [2S-05] na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije bool", null);
                        }
                    break;

                case STRING:

                    if(TabUtils.stringType.equals(type)){

                       konstanta = Tab.insert(Obj.Con, id, type);
                       report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                    }else {
                       report_error("Semanticka greska [2S-06] na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije string", null);
                    }
                    break;
            }

        }
        else {
            report_error("Semanticka greska [2S-07] na liniji " + idleft + " : [R76] Ime konstante '" + konstanta.getName() + "' je vec definisano", null);
        }
    }

    public void varProcessing(String id, int idleft, Struct type, VarNode node){

        if(Tab.noType.equals(type)){
           report_error("Semanticka greska [2S-08] na liniji " + idleft + " : Tip promenljive nije definisan", null);
           return;
        }

        Obj promenljiva = Tab.currentScope().findSymbol(id);

        if(promenljiva == null){
            promenljiva =  Tab.noObj;
        }

        if (Tab.noObj.equals(promenljiva)) {

            Obj prom;

            switch(node){
                case GLOBAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);

                    globalPrimitiveVarsCount++;

                    report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case CLASS_VAR:

                    prom = Tab.insert(Obj.Fld, id, type);

                    if(!"this".equals(id) && !"super".equals(id)) {

                        innerClassAttributesCount++;

                        report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    }
                    break;

                case METHOD_LOCAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);
                    report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_FORMAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);
                    setFormalParam(prom);
                    TabUtils.formalParamCount++;
                    break;

                case GLOBAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    globalArraysCount++;
                    report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case CLASS_ARRAY_VAR:

                    prom = Tab.insert(Obj.Fld, id, new Struct(Struct.Array, type));

                    if(!"this".equals(id) && !"super".equals(id)) {

                         innerClassAttributesCount++;

                        report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    }
                    break;

                case METHOD_LOCAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_FORMAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    setFormalParam(prom);
                    TabUtils.formalParamCount++;
                    break;
            }

        }
        else {
            report_error("Semanticka greska [2S-09] na liniji " + idleft + " - Ime promeljive '" + promenljiva.getName() + "' je vec definisano", null);
        }
    }

    public void setFormalParam(Obj formParam){
           formParam.setFpPos(TabUtils.formalParamPosition++);
    }

    public Obj superClassProcessing(String superClass, int superClassleft){

        Obj result = Tab.noObj;
        if(superClass != null){

            Obj superClassObj = Tab.find(superClass);
            if(Tab.noObj.equals(superClassObj)){

                report_error("Semanticka greska [2S-11] na liniji " + superClassleft + " - nadklasa nije definisana", null);
            }else if(superClassObj.getKind() != Obj.Type && !Tab.nullType.equals(superClassObj.getType())){

                report_error("Semanticka greska [2S-12] na liniji " + superClassleft + " - Nadklasa nije tip i nije tipa klase", null);
            } else {

                extendingClassesCount++;
                result = superClassObj;
            }
        }

        return result;
    }

    public Obj classProcessing(String baseClass, int baseClassleft){

        Obj returnObj = Tab.noObj;

        Obj baseClassObj = Tab.find(baseClass);
        if(Tab.noObj.equals(baseClassObj)){

            TabUtils.currentClassObj = Tab.insert(Obj.Type, baseClass, new Struct(Struct.Class));

            returnObj = TabUtils.currentClassObj;

            innerClassesCount++;
        }else {
            report_error("Semanticka greska [2S-10] na liniji " + baseClassleft + " : [R84] Ime klase je vec definisano", null);
        }
        return returnObj;
    }

    public void addSuperFieldIntoClass(String superClass, Obj baseClass, int superClassleft) {

        Obj superObj = superClassProcessing(superClass, superClassleft);

        if(!Tab.noObj.equals(superObj) && !Tab.noObj.equals(baseClass)){

            varProcessing("super", 777, superObj.getType(), VarNode.CLASS_VAR);
        }
    }

    public boolean addAbstractClass(Obj absClass, ScopeNode scope){

        boolean result = false;

        if(!Tab.noObj.equals(absClass) && ScopeNode.ABSTRACT_CLASS.equals(scope)) {
            TabUtils.abstractClasses.put(absClass.getName(), absClass);
            result = true;
        }

        return result;
    }

    public void checkAbstractMethodExists(ScopeNode scope){

        if(ScopeNode.CLASS.equals(scope) && TabUtils.hasAbstractMethod){
            report_error("Semanticka greska: [R105] Klasa MORA biti apstraktna, posto sadrzi abs. metodu/e", null);
        }

        if(ScopeNode.ABSTRACT_CLASS.equals(scope) && !TabUtils.hasAbstractMethod){
           report_error("Semanticka greska : [R103] Abstrakna klasa MORA imati bar jednu abs. metodu", null);
        }

        TabUtils.hasAbstractMethod = false;
    }

    public void countMethods(ScopeNode scope){

        switch(scope){
            case GLOBAL:
                globalFunctionsCount++;
                break;
            case CLASS: case ABSTRACT_CLASS:
                innerClassMethodsCount++;
                break;
        }
    }

    public void setMethodParams(Obj methodObj){

        methodObj.setLevel(TabUtils.formalParamCount);
        Tab.chainLocalSymbols(methodObj);
    }

    public void insertThisParam(ScopeNode scope, VarNode var){

        if(ScopeNode.CLASS.equals(scope) || ScopeNode.ABSTRACT_CLASS.equals(scope)){
            varProcessing("this", 888, TabUtils.currentClassObj.getType(), var);
        }
    }

    public Obj getDesignator(String name, int nameleft, ScopeNode scope){

        Obj obj = Tab.noObj;

        // prvo trazi u unutrasnjim klasama ako si u dosegu
        if(ScopeNode.CLASS.equals(scope) || ScopeNode.ABSTRACT_CLASS.equals(scope)) {

            obj = TabUtils.findVarFromClassMethod(name);
        } else {

           obj = Tab.find(name);

           if("this".equals(obj.getName())) {
              report_error("Semanticka greska [2S-41] na liniji " + nameleft + " : name 'this' ne sme se koristiti u globalnom opsegu! ", null);
              return Tab.noObj;
           }
        }

        if(Tab.noObj.equals(obj)){
            report_error("Semanticka greska [2S-42] na liniji " + nameleft + " : name '" + name + "' nije deklarisano! ", null);
            return obj;
        }

        return obj;
    }

    public Obj getFieldFromClass(String fieldName, Obj className) {

        Obj field = null;

        if(className.getName().equals("this")){

             // field = Tab.currentScope.getOuter().findSymbol(fieldName);
             field = TabUtils.findInCurrentClassAndSuperClasses(fieldName);
        } else {

             // field = className.getType().getMembersTable().searchKey(fieldName);
             field = TabUtils.findFieldInClassAndSuperClasses(fieldName, className);
        }

        return field;
    }

    public Obj getClassDesignator(String name, int nameleft) {

        Obj result = Tab.noObj;
        Obj className = TabUtils.currentDesignatorObj;

        if(className.getType().getKind() != Struct.Class) {
             report_error("Semanticka greska [2S-45] na liniji " + nameleft + " : name " + className.getName() + " mora biti unutrasnja klasa! ", null);
             return result;
        }

        Obj classElement = getFieldFromClass(name, className);

        if(Tab.noObj.equals(classElement)) {

           report_error("Semanticka greska [2S-46] na liniji " + nameleft + " : name " + name + " nije deklarisano unutar klase! ", null);

        } else {

           TabUtils.currentDesignatorObj = classElement;
           result = classElement;
        }

        return result;
    }

    public Struct getRefArray(Struct type, Struct expr, int exprleft){

       Struct result = Tab.noType;

       if(TabUtils.isAbstractClass()){

          report_error("Semanticka greska [2S-37] na liniji " + exprleft + " :[R104] kreiranje niza tipom apstraktne klase!", null);
          return result;
       }

       if(Tab.intType.equals(expr)){

          objectCreationCount++;
          result = new Struct(Struct.Array, type);
       }
       else {
          report_error("Semanticka greska [2S-38] na liniji " + exprleft + " : broj elemenata niza mora biti tipa int! ", null);
       }

       return result;
    }

    public Struct newTypeStat(Struct type, int typeleft){

        Struct result = Tab.noType;

        if(TabUtils.isAbstractClass()){

          report_error("Semanticka greska [2S-39] na liniji " + typeleft + " :[R104] kreiranje objekta tipom apstraktne klase!", null);
          return result;
        }

        if(type.getKind() == Struct.Class){
           result = type;
        } else {
           report_error("Semanticka greska [2S-40] na liniji " + typeleft + " : unut. klasa mora biti koriscenja za new iskaz! ", null);
        }

        return result;
    }

    public boolean isTermsStringCompatible(Struct termLeft, Struct termRight) {

        return (termLeft.getKind() == Struct.Array && termLeft.getElemType().getKind() == Struct.Char &&
                termRight.getKind() == Struct.Array && termRight.getElemType().getKind() == Struct.Char) ? true : false;
    }

    public Struct addopTerms(Struct termLeft, Struct termRight, int line, int op){

        Struct result = Tab.noType;

        if( !termLeft.compatibleWith(termRight)){
             report_error("Semanticka greska [2S-33] na liniji " + line + " : addop izrazi nisu kompatibilni! ", null);
             return result;
        }

        if(op == 23) {

           if(termLeft.getKind() == Struct.Int && termRight.getKind() == Struct.Int) {

              result = Tab.intType;
           } else if(isTermsStringCompatible(termLeft, termRight)){

               result = TabUtils.stringType;
           }  else {

               report_error("Semanticka greska [2S-34] na liniji " + line + " : izrazi pri operaciji + moraju biti tipa int ili string! ", null);
           }
        } else if (op == 24) {

           if(termLeft.getKind() == Struct.Int && termRight.getKind() == Struct.Int) {
              result = Tab.intType;
           } else {
               report_error("Semanticka greska [2S-35] na liniji " + line + " : izrazi pri operaciji -, - moraju biti tipa int! ", null);
           }
        }

        return result;
    }

    public Struct mulopFactors(Struct factorLeft, Struct factorRight, int line){

        Struct result = Tab.noType;

        if(factorLeft.getKind() != Struct.Int || factorRight.getKind() != Struct.Int){
             report_error("Semanticka greska [2S-36] na liniji " + line + " : izrazi pri operacijama *, / i % moraju biti tipa int! ", null);
        }else {
            result = Tab.intType;
        }

        return result;
    }

    public Struct minusTerm(Struct termList, int termlistleft) {

        Struct result = Tab.noType;

        if(termList.getKind() == Struct.Int) {
           result = Tab.intType;
        } else {

           report_error("Semanticka greska [2S-32] na liniji " + termlistleft + " : iskaz mora biti tipa int", null);
           result = Tab.noType;
        }

        return result;
    }

    // TODO
   public boolean checkActParamsType(Obj func, int funcleft) {

      boolean isOK = true;

      if(TabUtils.actualParams.size() != 0){

          Iterator<Struct> actualParams = TabUtils.actualParams.iterator();
          Iterator<Obj> formalParams = func.getLocalSymbols().iterator();
          int counter = 1;

          // preskacemo this 0 parametar
          Collection<Obj> funcLocals = func.getLocalSymbols();
          Obj thisObj = (funcLocals.isEmpty()) ? Tab.noObj : ((Obj)funcLocals.toArray()[0]);

          if("this".equals(thisObj.getName())) {
              formalParams.next();
          }

          while(actualParams.hasNext() && formalParams.hasNext()) {

              if(!TabUtils.assignableTo(actualParams.next(), formalParams.next().getType())) {

                  report_error("Semanticka greska [2S-47] na liniji " + funcleft + " : stvarni parametar na poziciji " + counter + " nije kompatibilan pri dodeli sa formalnim parametrom metode.", null);
                  isOK = false;
              }
              counter++;
          }
      }

      return isOK;
   }

    public Struct checkFunc(Obj func, int funcleft, ScopeNode scope) {

        Struct result = Tab.noType;

        if(func.getKind() != Obj.Meth){

             report_error("Semanticka greska [2S-25] na liniji " + funcleft + " : name mora oznacavati metodu un.klase ili glob. metodu.", null);
             return result;
        }

        // treba nam ova provera zbog this argumenta kod klasa
        int actParamNum = TabUtils.actualParams.size();

        Collection<Obj> funcLocals = func.getLocalSymbols();
        Obj thisObj = (funcLocals.isEmpty()) ? Tab.noObj : ((Obj)funcLocals.toArray()[0]);

        if("this".equals(thisObj.getName())) {
             actParamNum++;
        }

        if(func.getLevel() != actParamNum){

          report_error("Semanticka greska [2S-26] na liniji " + funcleft + " : broj stvarnih i formalnih parametara se ne slaze", null);
          //return result;
        }

        if(!checkActParamsType(func, funcleft)){
            //return result;
        }

        // broji se funkcija
        if(TabUtils.hasMainFunc) {
           functionCallsInMainCount++;
        }

        // ispis poruke koriscenja globalne funkcije / metode unutrasnje klase
        // TODO sredi ovaj budz
        String fName = func.getName();
        boolean isGlobalMethod = (Tab.currentScope().getOuter().findSymbol(fName) != null) ? true : false;
        boolean initFunc = ("chr".equals(fName) || "ord".equals(fName) || "len".equals(fName)) ? true : false;
        if((ScopeNode.GLOBAL.equals(scope) && isGlobalMethod && TabUtils.isSingleName) || initFunc){

            report_info("Poziv globalne funkcije na liniji " + funcleft + " | " + TabUtils.printObj(func), null);

        } else {

            report_info("Poziv metode un.klase na liniji " + funcleft + " | " + TabUtils.printObj(func), null);
        }

        return func.getType();
    }

    public boolean checkRefTypeOperator(Struct exp1, Struct exp2, int op) {

        return (exp1.isRefType() && exp2.isRefType() && op != 0 && op != 1) ? true : false;
    }

    public boolean condFactCheck(Struct exp1, Struct exp2, int exp1left, int op) {

        boolean result = true;

        if( !exp1.compatibleWith(exp2)) {

           report_error("Semanticka greska [2S-30] na liniji " + exp1left + " : pri uslovnim proverama tipovi nisu kompatibilni", null);
           result = false;
        }

        if(checkRefTypeOperator(exp1, exp2, op)) {

           report_error("Semanticka greska [2S-31] na liniji " + exp1left + " : pri uslovnim proverama tipovi klase ili niza mogu koristiti samo != i == operatore.", null);
           result = false;
        }

        return result;
    }

    public boolean condFactCheck(Struct exp, int expleft) {

            boolean result =  true;

            if(!TabUtils.boolType.equals(exp)) {

                report_error("Semanticka greska [2S-48] na liniji " + expleft + " : pri uslovnim proverama, izraz nije tipa bool!", null);

                result = false;
            }

            return true;
    }

    public boolean checkBasicType(Struct e) {

        return ( TabUtils.stringType.equals(e) || Struct.Char == e.getKind() ||
                 TabUtils.boolType.equals(e)   || Struct.Int == e.getKind() )
                 ? true : false;
    }

    public boolean isAssignableType(Obj d) {
        return (Obj.Var == d.getKind() || Obj.Elem == d.getKind() || Obj.Fld == d.getKind() ) ? true : false;
    }

    public void checkPrint(Struct e, int eleft) {

        if(!checkBasicType(e)) {

           report_error("Semanticka greska [2S-29] na liniji " + eleft + " : izraz u print f-ji mora biti int,char,bool ili string.", null);

        }

        if(TabUtils.hasMainFunc) {
           functionCallsInMainCount++;
        }
    }

    public void checkRead(Obj d, int dleft) {

        boolean isOk = true;

        if(!isAssignableType(d)) {

           report_error("Semanticka greska [2S-27] na liniji " + dleft + " : name u read izrazu mora biti promenljiva, elem niza ili polje klase.", null);
           isOk = false;

        }

        if(!checkBasicType(d.getType())){

            report_error("Semanticka greska [2S-28] na liniji " + dleft + " : izraz u read f-ji mora biti int,char,bool ili string.", null);

        }

        if(TabUtils.hasMainFunc) {
            functionCallsInMainCount++;
        }
    }

    public boolean checkEqualExpr(Obj d, Struct s, int dleft) {

        boolean isOk = true;

        if(!isAssignableType(d)) {

           report_error("Semanticka greska [2S-19] na liniji " + dleft + " : name sa leve strane izraza dodele vrednosti mora biti promenljiva, elem niza ili polje klase.", null);
           isOk = false;
        }

        if(!TabUtils.assignableTo(d.getType(), s)){

            report_error("Semanticka greska [2S-20] na liniji " + dleft + " : promenljive sa leve i desne strane izraza dodele nisu kompatibilni.", null);
            isOk = false;
        }

        return isOk;
    }

    public boolean checkIncDecExpr(Obj d, int dleft) {

        boolean isOk = true;

        if(!isAssignableType(d)) {

           report_error("Semanticka greska [2S-21] na liniji " + dleft + " : name u increment/decrement izrazu mora biti promenljiva, elem niza ili polje klase.", null);
           isOk = false;
        }

        if(!Tab.intType.equals(d.getType())){

            report_error("Semanticka greska [2S-22] na liniji " + dleft + " : increment/decrement izraz mora biti tipa int.", null);
            isOk = false;
        }

        return isOk;
    }

    public void checkMainFunction(int mleft) {

        if(!Tab.noObj.equals(TabUtils.currentMethodObj) && "main".equals(TabUtils.currentMethodObj.getName())){

            if(Tab.currentScope().getnVars() > 0) {

                report_error("Semanticka greska [2S-14] na liniji " + mleft + " : main funkcija ne sme imati lokalne i formalne argumente.", null);
            }

            if(!TabUtils.currentMethodObj.getType().equals(Tab.noType)) {

               report_error("Semanticka greska [2S-15] na liniji " + mleft + " : main funkcija mora biti tipa void.", null);
            }
        }
    }

    public void checkReturnStat(Struct exp, int expleft) {

        if(!TabUtils.currentMethodObj.getType().equals(exp)) {
            report_error("Semanticka greska [2S-23] na liniji " + expleft + " : povratni tip metode se ne slaze sa tipom return izraza.", null);
        }
    }

    public boolean findMethodName(String methName, int methNameleft) {

        boolean result = false;

        if(methName.equals("main")) {
            TabUtils.hasMainFunc = true;
        }

        Obj findedMeth = Tab.currentScope.findSymbol(methName);

        if(findedMeth != null) {
            report_error("Semanticka greska [2S-13] na liniji " + methNameleft + " : metoda je vec deklarisana.", null);
            result = true;
        }

        return result;
    }

    public void checkReturnExp(String methName){

        if(!TabUtils.returnFound && !TabUtils.isVoid) {
            report_error("Semanticka greska [2S-16] - nije nadjen return izraz za metodu '" + methName + "'.", null);
        }

        if(TabUtils.returnFound && TabUtils.isVoid) {
            report_error("Semanticka greska [2S-17] - nadjen return izraz za metodu '" + methName + "' koja je void.", null);
        }
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null)
	//	log.info(s.toString() + " " + s.value.toString());
	return s;
:}


init with {:
	 Tab.init(); // Universe scope

	 // setujemo Bool i String tipove u universe scope
	 Scope universe = Tab.currentScope();

	 universe.addToLocals(new Obj(Obj.Type, "bool", TabUtils.boolType));
	 universe.addToLocals(new Obj(Obj.Type, "string", TabUtils.stringType));
:}

action code {:

    ScopeNode scope = ScopeNode.GLOBAL;
    VarNode var = VarNode.GLOBAL_VAR;
    ConstNode con = ConstNode.NUMBER;
:}

terminal PROG, CONST, VOID, ABSTRACT, CLASS, EXTENDS, NEW;
terminal IF, ELSE, WHILE, PRINT, READ, BREAK, RETURN;
terminal PLUS, MINUS, TIMES, DIV, MOD;
terminal ISEQUAL, ISNOTEQUAL, ISGREATER, ISGREATEREQ, ISLESS, ISLESSEQ;
terminal OR, AND;
terminal EQUAL, INCREMENT, DECREMENT;
terminal LBRACE, RBRACE, RSQUARE, LSQUARE, LPAREN, RPAREN, DOT, COMMA, SEMI;

terminal Integer NUMBER ;
terminal Boolean BOOLVAL ;
terminal Character CHARCONST ;
terminal String STRING_LITERAL ;
terminal String IDENT ;

non terminal Program, GlobalDeclaration, GlobalDeclList, GlobalDeclPart;
non terminal ConstDecl, ConstDeclSemi, ConstDeclList, ConstDeclPart;
non terminal VarDecl, VarList, VarPart, VarPart_Comma_Recovery, VarPart_Semi_Recovery;
non terminal ClassDecl, AbsClass;
non terminal ClassDefinition, ClassVarList, ClassVarPart, ClassVarList_RBRACE_Recovery;
non terminal ClassMethodDecl, ClassMethodList, ClassMethodPart;
non terminal C_VarDecl, C_VarList;
non terminal MethodDecl, MethodDeclList, MethodDeclPart;
non terminal MethodVarDeclList, LocalVarDecl_Semi_Recovery, LocalVarDecl_Lbrace_Recovery;
non terminal M_VarList;
non terminal FormPars, ActualPars, ActualParamList, ActualPars_Rparen_Recovery;
non terminal FormPars_Recovery, FormalParamDecl_Comma_Recovery, FormalParamDecl_Rparen_Recovery;
non terminal FormalParamType;
non terminal AllStatements, StatementList, Statement;
non terminal Unmatched, Matched, WhileBreak;
non terminal MethodVarDeclLB_Recovery;

non terminal Integer Addop, Mulop, Relop;

non terminal Obj ProgBegin, ClassExtendsLB_Recovery, MethodName;
non terminal Obj Designator, DesignatorList, DesignatorPart, ExprInSquaresRS_Recovery, ProgramFunc;
non terminal Struct Type, MethodRetType, Term, Term_list, Expr, Factor, Factor_list;

non terminal Boolean Brace_condition, Condition, CondTermOR, CondTerm, CondFactAND, CondFact;
non terminal Struct Dodela;
non terminal FuncCalls;

Program ::= PROG ProgBegin:p GlobalDeclaration LBRACE MethodDecl RBRACE
            {:
                if(!TabUtils.hasMainFunc) {
                   parser.report_error("Semanticka greska - [2S-00] Nije pronadjena main funkcija", null);
                }

                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :}
            |
            PROG ProgBegin:p GlobalDeclaration LBRACE  RBRACE
            {:
                Tab.chainLocalSymbols(p);
                parser.report_error("Semanticka greska - [2S-00] Nije pronadjena main funkcija", null);
                Tab.closeScope();
            :};

ProgBegin ::=  IDENT:id
                {:
                    RESULT = Tab.insert(Obj.Prog, id, Tab.noType);
                    Tab.openScope();
                :};

GlobalDeclaration ::=  GlobalDeclList
                        |
                       /* epsilon */;

GlobalDeclList ::= GlobalDeclList GlobalDeclPart
				   |
				   GlobalDeclPart ;


GlobalDeclPart ::=  ConstDecl
                    |
                    VarDecl
                    |
                    ClassDecl;


Type ::= IDENT:typeName
         {:

            Obj typeNode = Tab.find(typeName);

            TabUtils.currentTypeNameUses = typeName;

            if (typeNode.equals(Tab.noObj)) {

                parser.report_error("Semanticka greska - [2S-01] Nije pronadjen tip '" + typeName + "' u tabeli simbola", null);
                RESULT = Tab.noType;
            }
            else {
                if (Obj.Type == typeNode.getKind()) {
                    RESULT = typeNode.getType();
                }
                else {
                    parser.report_error("Semanticka greska [2S-02] na liniji " + typeNameleft + " : Ime " + typeName + " ne predstavlja tip ", null);
                    RESULT = Tab.noType;
                }
            }

        :};


// ---------------------- CONST DECL --------------------------

ConstDeclSemi ::= CONST Type:tip
                  {:
                     TabUtils.currentVarType = tip;
                  :}
                  ConstDeclList;


ConstDecl ::= ConstDeclSemi SEMI
              |
              error SEMI:e
              {:
                 parser.report_error("Sintaksna greska [1S-00] na liniji "+ eleft + " : prilikom definicije glob. konstante, izvrsen oporavak do ; ", null);
              :};

ConstDeclList ::= ConstDeclList COMMA ConstDeclPart
                     |
                  ConstDeclPart
                     |
                  error COMMA:l
                   {:
                      parser.report_error("Sintaksna greska [1S-01] na liniji " + lleft + " : prilikom definicije glob. konstante, izvrsen oporavak do , ", null);
                   :};

ConstDeclPart ::= IDENT:id EQUAL NUMBER:num
                  {:
                    con = ConstNode.NUMBER;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL CHARCONST:ch
                  {:
                    con = ConstNode.CHAR;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL BOOLVAL:bool
                  {:
                    con = ConstNode.BOOL;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL STRING_LITERAL:str
                  {:
                    con = ConstNode.STRING;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :};

// ---------------------- VAR DECL --------------------------

VarDecl ::= Type:typeName
            {:
                TabUtils.currentVarType = typeName;
                var = VarNode.GLOBAL_VAR;
            :}
            VarList;

VarList ::= VarPart_Comma_Recovery VarList
            |
            VarPart_Semi_Recovery;

VarPart_Semi_Recovery ::= VarPart SEMI
                          |
                          error SEMI:l
                          {:
                            parser.report_error("Sintaksna greska [1S-02] na liniji " + lleft + " : prilikom definicije glob. prom., izvrsen oporavak do ;", null);
                          :};

VarPart_Comma_Recovery ::= VarPart COMMA
                           |
                           error COMMA:cl
                           {:
                               parser.report_error("Sintaksna greska [1S-03] na liniji " + clleft + " : prilikom definicije glob. prom., izvrsen oporavak do ,", null);
                           :};

VarPart ::= IDENT:id
            {:
                parser.varProcessing(id, idleft, TabUtils.currentVarType, var);
            :}
            |
            IDENT:id LSQUARE RSQUARE
            {:
                VarNode arrayVar = VarNode.varToArray(var);
                parser.varProcessing(id, idleft, TabUtils.currentVarType, arrayVar);
            :};


// ---------------------- CLASS DECL --------------------------


AbsClass ::=  CLASS
              {:
                 scope = ScopeNode.CLASS;
              :}
              |
              ABSTRACT CLASS
              {:
                 scope = ScopeNode.ABSTRACT_CLASS;
              :};

ClassDecl ::= AbsClass ClassExtendsLB_Recovery:classObj ClassDefinition
              {:

                 if(!Tab.noObj.equals(classObj)){

                    Tab.chainLocalSymbols(classObj.getType());

                    parser.addAbstractClass(classObj, scope);

                    parser.checkAbstractMethodExists(scope);

                    parser.report_info("Nadjena klasa na liniji " + classObjleft + " | " + TabUtils.printObj(classObj), null);
                 }

                 Tab.closeScope();

                 TabUtils.currentClassObj = Tab.noObj;

                 scope = ScopeNode.GLOBAL;
              :};

ClassExtendsLB_Recovery ::= IDENT:baseClass EXTENDS IDENT:superClass LBRACE
                            {:
                                RESULT = parser.classProcessing(baseClass, baseClassleft);

                                Tab.openScope();

                                parser.addSuperFieldIntoClass(superClass, RESULT, superClassleft);
                            :}
                            |
                            IDENT:baseClass LBRACE
                            {:
                                RESULT = parser.classProcessing(baseClass, baseClassleft);

                                Tab.openScope();
                            :}
                            |
                            error LBRACE:l
                            {:
                                parser.report_error("Sintaksna greska [1S-04] na liniji " + lleft + " : prilikom prosirenja nadklase, izvrsen oporavak do {", null);

                                RESULT = Tab.noObj;
                                Tab.openScope();
                            :};

ClassDefinition ::= ClassVarList_RBRACE_Recovery
                    |
                    ClassMethodDecl RBRACE
                    |
                    RBRACE;

ClassVarList_RBRACE_Recovery ::= ClassVarList ClassMethodDecl RBRACE
                                 |
                                 ClassVarList RBRACE
                                 |
                                 error RBRACE:l
                                 {:
                                    parser.report_error("Sintaksna greska [1S-05] na liniji " + lleft + " : prilikom definicije atributa klase, izvrsen oporavak do }", null);
                                 :};

ClassVarList ::= ClassVarList ClassVarPart
                 |
                 ClassVarPart;

ClassVarPart ::= C_VarDecl SEMI
                 |
                 error SEMI:l
                 {:
                     parser.report_error("Sintaksna greska [1S-06] na liniji " + lleft + " : prilikom definicije atributa klase, izvrsen oporavak do ;", null);
                 :};

C_VarDecl ::=  Type:typeName
              {:
                 TabUtils.currentVarType = typeName;
                 var = VarNode.CLASS_VAR;
              :}
              C_VarList;

C_VarList ::= C_VarList COMMA VarPart
              |
              VarPart;

ClassMethodDecl ::= LBRACE ClassMethodList RBRACE;

ClassMethodList ::= ClassMethodList ClassMethodPart
                    |
                    ClassMethodPart;

ClassMethodPart ::= MethodDeclPart;


// ---------------------- METHOD DECL --------------------------


MethodDecl ::= MethodDeclList;

MethodDeclList ::= MethodDeclList MethodDeclPart
                   |
                   MethodDeclPart;

MethodRetType ::= Type:retType
                  {:
                        TabUtils.isVoid = Tab.noType.equals(retType) ? true : false;
                        RESULT = retType;
                  :}
                  |
                  VOID
                  {:
                       TabUtils.isVoid = true;
                       RESULT = Tab.noType;
                  :};

MethodName ::= MethodRetType:retType IDENT:methName
                {:
                    TabUtils.isMethodExist = parser.findMethodName(methName, methNameleft);

                    RESULT = Tab.insert(Obj.Meth, methName, retType);

                    TabUtils.currentMethodObj = RESULT;
                    Tab.openScope();

                    var = VarNode.METHOD_FORMAL_VAR;
                    parser.insertThisParam(scope, var);
                :};

MethodVarDeclLB_Recovery ::= MethodVarDeclList:m
                             {:
                                  parser.checkMainFunction(mleft);
                             :}
                             |
                             LBRACE:l
                             {:
                                  parser.checkMainFunction(lleft);
                             :};

MethodDeclPart ::= MethodName:methName LPAREN FormPars_Recovery MethodVarDeclLB_Recovery AllStatements RBRACE
                   {:

                      if(!TabUtils.isMethodExist) {

                          parser.countMethods(scope);
                          parser.checkReturnExp(methName.getName());
                          parser.setMethodParams(methName);
                      }

                      TabUtils.resetMethodsFlags();

                      Tab.closeScope();
                   :}
                   |
                   ABSTRACT MethodName:methName LPAREN FormPars_Recovery SEMI
                   {:
                     if(!scope.equals(ScopeNode.ABSTRACT_CLASS)){
                         parser.report_error("Semanticka greska [2S-18] - apstraktna metoda deklarisana van apstraktne klase na liniji " + methNameleft, null);
                     }

                     TabUtils.hasAbstractMethod = true;

                     // ne broji se posto su abstraktne metode, deklaracije a ne definicije
                     // parser.countMethods(scope);

                     if(!TabUtils.isMethodExist) {
                         parser.checkReturnExp(methName.getName());
                         parser.setMethodParams(methName);
                         TabUtils.abstractMethods.put(TabUtils.currentClassObj.getName(), methName.getName());
                     }

                     TabUtils.resetMethodsFlags();

                     Tab.closeScope();
                   :};





MethodVarDeclList ::= LocalVarDecl_Semi_Recovery MethodVarDeclList
                      |
                      LocalVarDecl_Lbrace_Recovery;


LocalVarDecl_Semi_Recovery ::= Type:typeName
                               {:
                                   TabUtils.currentVarType = typeName;
                               :}
                               M_VarList SEMI
                               |
                               error SEMI:l
                               {:
                                    parser.report_error("Sintaksna greska [1S-07] na liniji " + lleft + " : prilikom definicije lokalnih prom. metode, izvrsen oporavak do ;", null);
                               :};


LocalVarDecl_Lbrace_Recovery ::= LocalVarDecl_Semi_Recovery LBRACE
                                 |
                                 error LBRACE:l
                                 {:
                                     parser.report_error("Sintaksna greska [1S-08] na liniji " + lleft + " : prilikom deklaracije lokalnih prom., izvrsen oporavak do {", null);
                                 :};

M_VarList ::= M_VarList COMMA VarPart
              |
              VarPart;


// ---------------------- FORM PARAMS --------------------------

FormPars_Recovery ::= FormPars
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :}
                      |
                      RPAREN
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :};



FormPars ::= FormalParamDecl_Comma_Recovery FormPars
					|
			 FormalParamDecl_Rparen_Recovery;

FormalParamDecl_Comma_Recovery ::= FormalParamType VarPart COMMA
                                   |
                                   error COMMA:l
                                   {:
                                       parser.report_error("Sintaksna greska [1S-09] na liniji " + lleft + " : prilikom deklaracije formalnih prom, izvrsen oporavak do ,", null);
                                   :};

FormalParamDecl_Rparen_Recovery ::= FormalParamType VarPart RPAREN
                                    {:

                                    :}
                                    |
                                    error RPAREN:l
                                    {:
                                        parser.report_error("Sintaksna greska [1S-10] na liniji " + lleft + " : prilikom deklaracije formalnih prom, izvrsen oporavak do )", null);
                                    :};

FormalParamType ::= Type:typeName
                    {:
                        TabUtils.currentVarType = typeName;
                    :};


// ---------------------- STATEMENTS --------------------------


AllStatements ::= StatementList
                        |
                     /* epsilon */;

StatementList ::= StatementList Statement
				  |
				  Statement;

Statement ::= Matched | Unmatched ;

WhileBreak ::= WHILE {: TabUtils.inWhile = true; :};

Unmatched ::= IF Brace_condition:cond Statement
              {:

              :}
              |
              IF Brace_condition:cond Matched ELSE Unmatched
              {:

              :}
              |
              WhileBreak Brace_condition:cond Unmatched
              {:
                  TabUtils.inWhile = false;
              :};


Matched ::= Designator:dest EQUAL Dodela:d
            {:
                 parser.checkEqualExpr(dest, d, destleft);
            :}
            |
            Designator:dest INCREMENT SEMI
            {:
                  parser.checkIncDecExpr(dest, destleft);
            :}
            |
            Designator:dest DECREMENT SEMI
            {:
                  parser.checkIncDecExpr(dest, destleft);
            :}
            |
            FuncCalls
            |
            IF Brace_condition:cond Matched ELSE Matched
            {:

            :}
            |
            WhileBreak Brace_condition:cond Matched
            {:
                TabUtils.inWhile = false;
            :}
            |
            RETURN Expr:t SEMI
            {:
                TabUtils.returnFound = true;
                parser.checkReturnStat(t, tleft);
            :}
            |
            RETURN:r SEMI
            {:
                TabUtils.returnFound = true;
                parser.checkReturnStat(Tab.noType, rleft);
            :}
            |
            BREAK:b SEMI
            {:
                if(!TabUtils.inWhile){
                    parser.report_error("Semanticka greska [2S-24] na liniji " + bleft + " : break iskaz se poziva van while petlje", null);
                }
            :}
            |
            LBRACE
            {:
                parser.statementsCount++;
            :}
            AllStatements RBRACE;


Brace_condition ::= LPAREN Condition:c RPAREN
                    {:
                        RESULT = c;
                    :}
                    |
                    error RPAREN:l
                    {:
                        parser.report_error("Sintaksna greska [1S-11] na liniji " + lleft + " : logickog izraza unutar if ili while konstrukcije, izvrsen oporavak do prvog znaka )",null);
                        TabUtils.conditionError = true;
                        RESULT = false;
                    :};

Dodela ::= 	Expr:e SEMI
            {:
                /*
                if (parser.isInMain() && !parser.indeksGreska()) parser.incIskaza ();
                parser.resetIndeksGreska();

                RESULT = e;
                */
                 RESULT = e;
            :}
            |
            error SEMI:l
            {:

                parser.report_error("Sintaksna greska [1S-12] na liniji " + lleft + " : prilikom dodele vrednosti, izvrsen oporavak do ;",null);
                RESULT = Tab.noType;

            :};

ProgramFunc ::= Designator:d LPAREN
                {:
                     TabUtils.actualParamCount = 0;
                     TabUtils.actualParams = new ArrayList<Struct>();
                     RESULT = d;
                :};

FuncCalls ::= ProgramFunc:func ActualPars_Rparen_Recovery:ap SEMI
              {:
                   RESULT = parser.checkFunc(func, funcleft, scope);
              :}
              |
              READ LPAREN Designator:d RPAREN SEMI
              {:

                  parser.checkRead(d, dleft);
              :}
              |
              PRINT LPAREN Expr:e RPAREN SEMI
              {:
                   parser.checkPrint(e, eleft);
              :}
              |
              PRINT LPAREN Expr:e COMMA NUMBER RPAREN SEMI
              {:
                    parser.checkPrint(e, eleft);
              :}
              |
              error SEMI:l
              {:
                  parser.report_error("Sintaksna greska [1S-13] na liniji " + lleft + " : prilikom poziva funkcije, izvrsen oporavak do ;",null);
              :};

Condition ::= CondTermOR:cor {: RESULT = cor; :};

CondTermOR ::= CondTermOR:cor OR CondTerm:ct
               {:
                    RESULT = (ct || cor) ? true : false;
               :}
               |
               CondTerm:c
               {:
                    RESULT = c;
               :};

CondTerm ::= CondFactAND:cand {: RESULT = cand; :};

CondFactAND ::= CondFactAND:cand AND CondFact:cf
                {:
                    RESULT = (cf && cand) ? true : false;
                :}
                |
                CondFact:cf
                {:
                     RESULT = cf;
                :};

CondFact ::= Expr:exp1 Relop:op Expr:exp2
             {:
                  RESULT = parser.condFactCheck(exp1, exp2, exp1left, op);
             :}
             |
             Expr:exp1
             {:
                 // RESULT = exp1;
                 // TODO odraditi logiku za proveru vrednosti i na osnovu nje definisati da li je   DONE
                 // CondFact true/false

                 RESULT = parser.condFactCheck(exp1, exp1left);
             :};


Expr ::= Term_list:tl
         {:
             RESULT = tl;
         :}
         |
         MINUS Term_list:tl
         {:
             RESULT = parser.minusTerm(tl, tlleft);
         :};

Term_list ::= Term_list:t Addop:op Term:r
              {:
                   RESULT = parser.addopTerms(t, r, rleft, op);
              :}
              |
              Term:trm
              {:
                   RESULT = trm;
              :};

Term ::= Factor_list:fl
         {:
             RESULT = fl;
         :};

Factor_list ::= Factor_list:fl Mulop:op Factor:ff
                {:
                    RESULT = parser.mulopFactors(fl, ff, flleft);
                :}
                |
                Factor:f
                {:
                    RESULT = f;
                :};

Factor ::= NUMBER
           {:
              RESULT = Tab.intType;
           :}
           |
           CHARCONST
           {:
               RESULT = Tab.charType;
           :}
           |
           LPAREN Expr:e RPAREN
           {:
               RESULT = e;
           :}
           |
           BOOLVAL
           {:
               RESULT = TabUtils.boolType;
           :}
           |
           STRING_LITERAL
           {:
               RESULT = TabUtils.stringType;
           :}
           |
           NEW Type:id LSQUARE Expr:e RSQUARE
           {:
               RESULT = parser.getRefArray(id, e, eleft);
           :}
           |
           NEW Type:id
           {:
               parser.objectCreationCount++;
               RESULT =  parser.newTypeStat(id, idleft);
           :}
           |
           Designator:d
           {:
               if(d.getType() == null) {

                    RESULT = Tab.noType;
               } else {

                    RESULT = d.getType();
               }
           :}
           |
           ProgramFunc:func ActualPars_Rparen_Recovery:ap
           {:
               RESULT = parser.checkFunc(func, funcleft, scope);
           :};

ActualPars_Rparen_Recovery ::= ActualPars RPAREN:lt
                               {:

                               :}
                               |
                               error RPAREN:l
                               {:
                                  parser.report_error("Sintaksna greska [1S-14] na liniji " + lleft + " : u listi parametara pri pozivu f-je, izvrsen oporavak do )",null);
                               :};


ActualPars ::= ActualParamList
			   |
			   /* epsilon */  ;

ActualParamList ::= ActualParamList COMMA Expr:e
                    {:
                       TabUtils.actualParams.add(e);
                    :}
					|
					Expr:e
					{:
                       TabUtils.actualParams.add(e);
					:};

Designator ::= IDENT:name
                {:
                    TabUtils.isSingleName = false;

                    TabUtils.currentDesignatorObj = parser.getDesignator(name, nameleft, scope);
                :}
                DesignatorList:dsList
                {:
                    RESULT = dsList;
                    TabUtils.currentDesignatorObj = Tab.noObj;
                :}
                |
                IDENT:name
                {:
                    TabUtils.isSingleName = true;

                    RESULT = parser.getDesignator(name, nameleft, scope);
                :};

DesignatorList ::= DesignatorList DesignatorPart:dlp
                   {:
                        RESULT = dlp;
                   :}
                   |
                   DesignatorPart:dp
                   {:
                        RESULT = dp;
                   :};

ExprInSquaresRS_Recovery ::= LSQUARE Expr:e RSQUARE
                             {:
                                  if(!Tab.intType.equals(e)){
                                    parser.report_error("Semanticka greska [2S-43] na liniji " + eleft + " : index niza mora biti tipa int! ", null);
                                  }
                             :}
                             |
                             error RSQUARE:l
                             {:
                                parser.report_error("Sintaksna greska [1S-15] na liniji " + lleft + " : izraza za index. niza, izvrsen oporavak do ]",null);
                             :};

DesignatorPart ::=  ExprInSquaresRS_Recovery:exSqr
                    {:
                        if(TabUtils.currentDesignatorObj.getType().getKind() != Struct.Array){

                            parser.report_error("Semanticka greska [2S-44] na liniji " + exSqrleft + " : nadjeni element mora biti tipa niz! ", null);
                            RESULT = Tab.noObj;
                        } else {

                            RESULT = new Obj(Obj.Elem, "",TabUtils.currentDesignatorObj.getType().getElemType());
                        }
                    :}
                    |
                    DOT IDENT:name
                    {:
                         RESULT = parser.getClassDesignator(name, nameleft);
                    :};

Addop ::= PLUS {: RESULT = 23; :}
          |
          MINUS {: RESULT = 24; :};

Mulop ::= TIMES {: RESULT = 25; :}
          |
          DIV {: RESULT = 26; :}
          |
          MOD {: RESULT = 27; :};

Relop ::= ISEQUAL {: RESULT = 0; :}
          |
          ISNOTEQUAL {: RESULT = 1; :}
          |
          ISGREATER {: RESULT = 4; :}
          |
          ISGREATEREQ {: RESULT = 5; :}
          |
          ISLESS {: RESULT = 2; :}
          |
          ISLESSEQ {: RESULT = 3; :};

