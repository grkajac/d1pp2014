package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;


parser code {:

	// counting declarations vars
	int globalPrimitiveVarsCount = 0;
	int globalArraysCount = 0;

    // counting definitions vars
	int globalFunctionsCount = 0;
	int innerClassesCount = 0;

    //
	int statementsCount = 0;
	int functionCallsInMainCount = 0;
	int objectCreationCount = 0;

	// inner classes vars
	int innerClassAttributesCount = 0;
	int innerClassMethodsCount = 0;
	int extendingClassesCount = 0;


	// error detection var
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null)
	//	log.info(s.toString() + " " + s.value.toString());
	return s;
:}


init with {:
	Tab.init(); // Universe scope
:}

action code {:

    boolean inGlobalScope = true;
    boolean inClassScope = false;

    boolean inMainFunc = false;
    boolean isMethFormParams = false;
    boolean isMethLocalParams = false;

    boolean isSingleName = false;

    boolean conditionError = false;

	Obj currentMethod = null;
    Struct currentVarType = Tab.noType;              boolean isMainMeth = false;


	boolean returnFound = false;
    boolean isVoid = false;

    int paramCount = 0;
    boolean isField = false;
	boolean isOne = true;

    int redniBrParam = 0;

    Struct returnType;
:}

terminal PROG, CONST, VOID, CLASS, EXTENDS, NEW;
terminal IF, ELSE, WHILE, PRINT, READ, BREAK, RETURN;
terminal PLUS, MINUS, TIMES, DIV, MOD;
terminal ISEQUAL, ISNOTEQUAL, ISGREATER, ISGREATEREQ, ISLESS, ISLESSEQ;
terminal OR, AND;
terminal EQUAL, INCREMENT, DECREMENT;
terminal LBRACE, RBRACE, RSQUARE, LSQUARE, LPAREN, RPAREN, DOT, COMMA, SEMI;

terminal Integer NUMBER ;
terminal Boolean BOOLVAL ;
terminal Character CHARCONST ;
terminal String STRING_LITERAL ;
terminal String IDENT ;

non terminal Program, GlobalDeclaration, GlobalDeclList, GlobalDeclPart;
non terminal ConstDecl,ConstDeclList, ConstDeclPart;
non terminal VarDecl, VarList, VarPart, VarPart_Comma_Recovery, VarPart_Semi_Recovery;
non terminal ClassDecl, ClassExtendsLB_Recovery;
non terminal ClassDefinition, ClassVarList, ClassVarPart, ClassVarList_RBRACE_Recovery;
non terminal ClassMethodDecl, ClassMethodList, ClassMethodPart;
non terminal C_VarDecl, C_VarList;
non terminal MethodDecl, MethodDeclList, MethodDeclPart, MethodRetType;
non terminal MethodVarDeclList, LocalVarDecl_Semi_Recovery, LocalVarDecl_Lbrace_Recovery;
non terminal M_VarList;
non terminal FormPars, ActualPars, ActualParamList, ActualPars_Rparen_Recovery;
non terminal FormPars_Recovery, FormalParamDecl_Comma_Recovery, FormalParamDecl_Rparen_Recovery;
non terminal AllStatements, StatementList, Statement;
non terminal Unmatched, Matched;
non terminal ExprInSquaresRS_Recovery;
non terminal DesignatorList, DesignatorPart;
non terminal MethodVarDeclLB_Recovery;

non terminal Condition, CondTermOR, CondTerm, CondFactAND, CondFact ;
non terminal Addop, Mulop, Relop;

non terminal Obj ProgBegin, Designator, MethodName;
non terminal Struct Type, Term, Term_list, Expr, Factor, Factor_list;

non terminal Integer Brace_condition;
non terminal Struct Dodela;
non terminal FuncCalls, ProgramFunc;

Program ::= PROG ProgBegin:p GlobalDeclaration LBRACE MethodDecl RBRACE
            {:
                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :}
            |
            PROG ProgBegin:p GlobalDeclaration LBRACE  RBRACE
            {:
                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :};

ProgBegin ::=  IDENT:id
                {:
                    RESULT = Tab.insert(Obj.Prog, id, Tab.noType);
                    Tab.openScope();
                :};

GlobalDeclaration ::=  GlobalDeclList
                        |
                       /* epsilon */;

GlobalDeclList ::= GlobalDeclList GlobalDeclPart
				   |
				   GlobalDeclPart ;


GlobalDeclPart ::=  ConstDecl
                    |
                    VarDecl
                    |
                    ClassDecl;


Type ::= IDENT:typeName
         {:
            Obj typeNode = Tab.find(typeName);
            if (typeNode == Tab.noObj) {
                parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", null);
                RESULT = Tab.noType;
            }
            else {
                if (Obj.Type == typeNode.getKind()) {
                    RESULT = typeNode.getType();
                }
                else {
                    parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
                    RESULT = Tab.noType;
                }
            }
        :};


ConstDecl ::= CONST Type:tip
              {:

              :}
              ConstDeclList SEMI
              |
              error SEMI:e
              {:
                 parser.report_error("Sintaksna greska prilikom definicije glob. konstante na liniji "+eleft+" izvrsen oporavak do ; ", null);
              :};

ConstDeclList ::= ConstDeclList COMMA ConstDeclPart
                     |
                  ConstDeclPart
                     |
                  error COMMA:l
                   {:
                      parser.report_error("Sintaksna greska prilikom definicije glob. konstante na liniji "+lleft+" izvrsen oporavak do , ", null);
                   :};

ConstDeclPart ::= IDENT:id EQUAL NUMBER:num
                  {:
                  :}
                  |
                  IDENT:id EQUAL CHARCONST:ch
                  {:
                  :}
                  |
                  IDENT:id EQUAL BOOLVAL:bool
                  {:
                  :}
                  |
                  IDENT:id EQUAL STRING_LITERAL:str
                  {:
                  :};

VarDecl ::= Type:typeName
                {:
                    currentVarType = typeName;
                :}
                VarList;

VarList ::= VarPart_Comma_Recovery VarList
            |
            VarPart_Semi_Recovery;

VarPart_Semi_Recovery ::= VarPart SEMI
                            |
                          error SEMI:l
                          {:
                            parser.report_error("Sintaksna greska prilikom definicije glob. prom. na liniji "+lleft+" izvrsen oporavak do ;", null);
                          :}
                          ;

VarPart_Comma_Recovery ::= VarPart COMMA
                               |
                            error COMMA:cl
                            {:
                                parser.report_error("Sintaksna greska prilikom definicije glob. prom. na liniji "+clleft+" izvrsen oporavak do ,", null);
                            :};

VarPart ::= IDENT:id
                {:
                    if(inGlobalScope) {
                        parser.globalPrimitiveVarsCount++;
                    }

                    if(inClassScope && !isMethFormParams && !isMethLocalParams) {
                       parser.innerClassAttributesCount++;
                    }
                :}
            |
            IDENT:id LSQUARE RSQUARE
                {:
                    if(inGlobalScope) {
                       parser.globalArraysCount++;
                    }

                    if(inClassScope && !isMethFormParams && !isMethLocalParams) {
                       parser.innerClassAttributesCount++;
                    }
                :};





MethodDecl ::= MethodDeclList;

MethodDeclList ::= MethodDeclList MethodDeclPart
                    |
                   MethodDeclPart;

MethodRetType ::= Type:retType
                    {:
                          isMethFormParams = true;
                    :}
                  |
                  VOID
                    {:
                         isVoid = true;
                         isMethFormParams = true;
                    :};

MethodName ::= MethodRetType:retType IDENT:methName
                {:
                    if(methName.equals("main")) {
                        inMainFunc = true;
                    }
                    inGlobalScope = false;
                    //parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
                :};

MethodVarDeclLB_Recovery ::= MethodVarDeclList
                             {:
                                isMethLocalParams = false;
                             :}
                             |
                             LBRACE
                             {:
                                isMethLocalParams = false;
                             :};

MethodDeclPart ::= MethodName:methName LPAREN FormPars_Recovery MethodVarDeclLB_Recovery AllStatements RBRACE
                     {:
                        inGlobalScope = true;
                        if(!inClassScope) {
                            parser.globalFunctionsCount++;
                        }else {
                            parser.innerClassMethodsCount++;
                        }

                        // reseting flags
                        inMainFunc = false;
                        isVoid = false;
                        returnFound = false;
                     :};

FormPars_Recovery ::= FormPars
                      {:
                          isMethFormParams = false;
                      :}
                      |
                      RPAREN
                      {:
                          isMethFormParams = false;
                          isMethLocalParams = true;
                      :};

FormPars ::= FormalParamDecl_Comma_Recovery FormPars
					|
			 FormalParamDecl_Rparen_Recovery;

FormalParamDecl_Comma_Recovery ::= Type:typeName VarPart COMMA
                                   |
                                   error COMMA:l
                                   {:
                                       parser.report_error("Sintaksna greska prilikom deklaracije formalnih prom na liniji "+lleft+" izvrsen oporavak do ,", null);
                                   :};

FormalParamDecl_Rparen_Recovery ::= Type:typeName VarPart RPAREN
                                    {:
                                        isMethLocalParams = true;
                                    :}
                                    |
                                    error RPAREN:l
                                    {:
                                         isMethLocalParams = true;
                                        parser.report_error("Sintaksna greska prilikom deklaracije formalnih prom na liniji "+lleft+" izvrsen oporavak do )", null);
                                    :};


MethodVarDeclList ::= LocalVarDecl_Semi_Recovery MethodVarDeclList
                        |
                      LocalVarDecl_Lbrace_Recovery;


LocalVarDecl_Semi_Recovery ::= Type:typeName M_VarList SEMI
                                  |
                                  error SEMI:l
                                  {:
                                       parser.report_error("Sintaksna greska prilikom definicije lokalnih prom. metode na liniji "+lleft+" izvrsen oporavak do ;", null);
                                  :};

LocalVarDecl_Lbrace_Recovery ::= Type:typeName M_VarList SEMI LBRACE
                                    |
                                    error LBRACE:l
                                    {:
                                        parser.report_error("Sintaksna greska prilikom deklaracije lokalnih prom. na liniji "+lleft+" izvrsen oporavak do {", null);
                                    :};

M_VarList ::= M_VarList COMMA VarPart
               |
              VarPart;

ClassDecl ::= CLASS ClassExtendsLB_Recovery ClassDefinition
                {:
                    inGlobalScope = true;
                    inClassScope = false;
                :};

ClassExtendsLB_Recovery ::= Type:baseClass EXTENDS Type:superClass LBRACE
                    {:
                        inGlobalScope = false;
                        inClassScope = true;
                        parser.extendingClassesCount++;
                        parser.innerClassesCount++;
                    :}
                    |
                 Type:baseClass LBRACE
                    {:
                        inGlobalScope = false;
                        inClassScope = true;
                        parser.innerClassesCount++;
                    :}
                    |
                 error LBRACE:l
                    {:                                          
                        parser.report_error("Sintaksna greska prilikom prosirenja nadklase na liniji "+lleft+" izvrsen oporavak do {", null);
                    :}
                    ;

ClassDefinition ::= ClassVarList_RBRACE_Recovery
                    |
                    ClassMethodDecl RBRACE
                    |
                    RBRACE;

ClassVarList_RBRACE_Recovery ::= ClassVarList ClassMethodDecl RBRACE
                                 |
                                 ClassVarList RBRACE
                                 |
                                 error RBRACE:l
                                 {:
                                    parser.report_error("Sintaksna greska prilikom definicije atributa klase na liniji "+lleft+" izvrsen oporavak do }", null);
                                 :}
                                 ;

ClassVarList ::= ClassVarList ClassVarPart
                  |
                 ClassVarPart;

ClassVarPart ::= C_VarDecl SEMI
                  |
                 error SEMI:l
                  {:
                      parser.report_error("Sintaksna greska prilikom definicije atributa klase na liniji "+lleft+" izvrsen oporavak do ;", null);
                  :};

C_VarDecl ::=  Type:typeName
              {:

              :}
              C_VarList;

C_VarList ::= C_VarList COMMA VarPart
              |
              VarPart;

ClassMethodDecl ::= LBRACE ClassMethodList RBRACE;

ClassMethodList ::= ClassMethodList ClassMethodPart
                        |
                    ClassMethodPart;

ClassMethodPart ::= MethodDeclPart;







AllStatements ::= StatementList
                        |
                     /* epsilon */;

StatementList ::= StatementList Statement
				  |
				  Statement;

Statement ::= Matched | Unmatched ;

Unmatched ::= IF Brace_condition:cond Statement
                {:

                :}
                |
              IF Brace_condition:cond Matched ELSE Unmatched
                {:
                :}
                |
              WHILE Brace_condition:cond Unmatched
                {:
                :};



Brace_condition ::= LPAREN Condition:c RPAREN
                        {:
                           // RESULT = c;
                        :}
                        |
                    error RPAREN:l
                        {:
                            parser.report_error("Sintaksna greska logickog izraza unutar if ili while konstrukcije na liniji "+lleft+" izvrsen oporavak do prvog znaka )",null);
                            conditionError = true;
                        :};

Dodela ::= 	Expr:e SEMI
		{:
		    /*
		    if (parser.isInMain() && !parser.indeksGreska()) parser.incIskaza ();
 			parser.resetIndeksGreska ();

			RESULT = e;
			*/
		:}
		|
		error SEMI:l
		{:

		    parser.report_error("Sintaksna greska prilikom dodele vrednosti na liniji "+lleft+" izvrsen oporavak do ;",null);
			// RESULT = Tab.noType;

		:} ;

ProgramFunc ::= Designator:d LPAREN
                {:

                     // broji se funkcija i u slucaju da se desi greska u njenim argumentima
                     if(inMainFunc && isSingleName) {
                         parser.functionCallsInMainCount++;
                     }
                :};

FuncCalls ::= ProgramFunc LPAREN ActualPars_Rparen_Recovery SEMI
                {:

                :}
                |
              READ LPAREN Designator RPAREN SEMI
                  {:
                      if(inMainFunc) {
                         parser.functionCallsInMainCount++;
                      }
                  :}
                 |
              PRINT LPAREN Expr RPAREN SEMI
                  {:
                        if(inMainFunc) {
                           parser.functionCallsInMainCount++;
                        }
                  :}
                |
              PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
                  {:
                        if(inMainFunc) {
                           parser.functionCallsInMainCount++;
                        }
                  :}
                |
              error SEMI:l
                   {:
                       parser.report_error("Sintaksna greska prilikom poziva funkcije na liniji "+lleft+" izvrsen oporavak do ;",null);
                   :}
                ;

Matched ::= Designator:dest EQUAL Dodela:d
                {:
                :}
               |
            Designator:dest INCREMENT SEMI
                {:
                :}
               |
            Designator:dest DECREMENT SEMI
                {:
                :}
              |
            FuncCalls
              |
            IF Brace_condition:cond Matched ELSE Matched
                {:
                :}
              |
            WHILE Brace_condition:cond Matched
                {:
                :}
               |
            RETURN Expr:t SEMI
                {:
                    returnFound = true;
                :}
               |
            RETURN SEMI
               |
            BREAK SEMI
               |
            LBRACE
                {:
                    parser.statementsCount++;
                :}
                AllStatements
            RBRACE;


Condition ::= CondTermOR;

CondTermOR ::= CondTermOR OR CondTerm
                |
               CondTerm;

CondTerm ::= CondFactAND;

CondFactAND ::= CondFactAND AND CondFact
              |
             CondFact;

CondFact ::= Expr:exp1 Relop Expr:exp2
                {:
                :}
             |
             Expr:exp1
                {:
                :}
             ;


Expr ::= Term_list:tl
             {:
                // RESULT = tl;
             :}
         |
         MINUS Term_list:tl
             {:
             :};

Term_list ::= Term_list:t Addop Term:r
             {:
             :}
           |
           Term:trm
            {:
            :};

Term ::= Factor_list:fl
         {:
             RESULT = fl;
         :};

Factor_list ::= Factor_list:fl Mulop Factor:ff
                {:
                 :}
              |
             Factor:f
                 {:
                 :};

Factor ::= NUMBER
        {:

        :}
        |
       CHARCONST
         {:

         :}
        |
        LPAREN Expr RPAREN
         {:
              //parser.report_info("XXXXX OVO BI TREBALOOOOO ", null);
         :}
         |
       BOOLVAL
         {:

         :}
         |
       STRING_LITERAL
         {:

         :}
         |
       NEW Type:id LSQUARE Expr RSQUARE
         {:
                parser.objectCreationCount++;
         :}
         |
       NEW Type:id
         {:
                parser.objectCreationCount++;
         :}
         |
       Designator:d
         {:

         :}
         |
       ProgramFunc ActualPars_Rparen_Recovery:lt
         {:

         :};

ActualPars_Rparen_Recovery ::= ActualPars RPAREN:lt
                               {:

                               :}
                               |
                               error RPAREN:l
                               {:
                                  parser.report_error("Sintaksna greska u listi parametara pri pozivu f-je na liniji "+lleft+" izvrsen oporavak do )",null);
                               :};


ActualPars ::= ActualParamList
				|
			   /* epsilon */  ;

ActualParamList ::= ActualParamList COMMA Expr
					|
					Expr ;

Designator ::= IDENT:name DesignatorList
                {:
                    isSingleName = false;
                :}
                |
                IDENT:name
                {:
                    isSingleName = true;
                :}
                ;

DesignatorList ::= DesignatorList DesignatorPart
                    |
                   DesignatorPart
                   ;

ExprInSquaresRS_Recovery ::= LSQUARE Expr RSQUARE
                             |
                             error RSQUARE:l
                             {:
                                parser.report_error("Sintaksna greska izraza za index. niza na liniji "+lleft+" izvrsen oporavak do ]",null);
                             :}
                             ;

DesignatorPart ::=  ExprInSquaresRS_Recovery
                        |
                    DOT IDENT:name
                    ;

Addop ::= PLUS
          |
          MINUS;

Mulop ::= TIMES
          |
          DIV
          |
          MOD;

Relop ::=     ISEQUAL
	      |   ISNOTEQUAL
	      |   ISGREATER
	      |   ISGREATEREQ
	      |   ISLESS
	      |   ISLESSEQ;

