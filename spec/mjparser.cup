package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;


parser code {:

	// counting declarations vars
	int globalPrimitiveVarsCount = 0;
	int globalArraysCount = 0;

    // counting definitions vars
	int globalFunctionsCount = 0;
	int innerClassesCount = 0;

    //
	int statementsCount = 0;
	int functionCallsInMainCount = 0;
	int objectCreationCount = 0;

	// inner classes vars
	int innerClassAttributesCount = 0;
	int innerClassMethodsCount = 0;
	int extendingClassesCount = 0;


	// error detection var
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        //report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

    /*
     * util functions
     */

    public void constantProcessing(String id, int idleft, Struct type, ConstNode node){

        Obj konstanta = Tab.find(id);

        if (konstanta.equals(Tab.noObj)) {

            switch(node){
                case NUMBER:

                    if(Tab.intType.equals(type)){

                       konstanta = Tab.insert(Obj.Con, id, type);
                       report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                    }else {
                       report_error("Semanticka greska na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije int", null);
                    }
                    break;

                case CHAR:

                        if(Tab.charType.equals(type)){

                           konstanta = Tab.insert(Obj.Con, id, type);
                           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                        }else {
                           report_error("Semanticka greska na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije char", null);
                        }
                    break;

                case BOOL:

                        if(TabUtils.boolType.equals(type)){

                           konstanta = Tab.insert(Obj.Con, id, type);
                           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                        }else {
                           report_error("Semanticka greska na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije bool", null);
                        }
                    break;

                case STRING:

                    if(TabUtils.stringType.equals(type)){

                       konstanta = Tab.insert(Obj.Con, id, type);
                       report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
                    }else {
                       report_error("Semanticka greska na liniji " + idleft + " : Tipovi nisu isti - Tip konstante nije string", null);
                    }
                    break;
            }

        }
        else {
            report_error("Semanticka greska na liniji " + idleft + " : [R76] Ime je vec definisano", null);
        }
    }

    public void varProcessing(String id, int idleft, Struct type, VarNode node){

        if(Tab.noType.equals(type)){
           report_error("Semanticka greska na liniji " + idleft + " : Tip promenljive nije definisan", null);
           return;
        }

        Obj promenljiva = Tab.find(id);

        // Tab.noObj.equals(promenljiva) && !type.equals(promenljiva.getType())
        if (Tab.noObj.equals(promenljiva)) {

            Obj prom;

            switch(node){
                case GLOBAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);
                    globalPrimitiveVarsCount++;
                    report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case CLASS_VAR:

                    prom = Tab.insert(Obj.Fld, id, type);
                    innerClassAttributesCount++;
                    report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_LOCAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);
                    report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_FORMAL_VAR:

                    prom = Tab.insert(Obj.Var, id, type);
                    setFormalParam(prom);
                    TabUtils.formalParamCount++;
                    break;

                case GLOBAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    globalArraysCount++;
                    report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case CLASS_ARRAY_VAR:

                    prom = Tab.insert(Obj.Fld, id, new Struct(Struct.Array, type));
                    innerClassAttributesCount++;
                    report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_LOCAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
                    break;

                case METHOD_FORMAL_ARRAY_VAR:

                    prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
                    setFormalParam(prom);
                    TabUtils.formalParamCount++;
                    break;
            }

        }
        else {
            report_error("Semanticka greska na liniji " + idleft + " - Ime je vec definisano", null);
        }
    }

    public void setFormalParam(Obj formParam){
           formParam.setFpPos(TabUtils.formalParamPosition++);
    }

    public boolean superClassProcessing(String superClass, int superClassleft){

        boolean result = false;
        if(superClass != null){

            Obj superClassObj = Tab.find(superClass);
            if(Tab.noObj.equals(superClassObj)){

                report_error("Semanticka greska na liniji " + superClassleft + " - nadklasa nije definisana", null);
            }else if(superClassObj.getKind() != Obj.Type && !Tab.nullType.equals(superClassObj.getType())){

                report_error("Semanticka greska na liniji " + superClassleft + " - Nadklasa nije tip i nije tipa klase", null);
            } else {
                result = true;
            }
        }

        return result;
    }

    public Obj classProcessing(String baseClass, int baseClassleft, String superClass, int superClassleft){

        Obj returnObj = Tab.noObj;

        if(superClassProcessing(superClass, superClassleft)){
            extendingClassesCount++;
        }


        Obj baseClassObj = Tab.find(baseClass);
        if(Tab.noObj.equals(baseClassObj)){

            TabUtils.currentClassObj = Tab.insert(Obj.Type, baseClass, new Struct(Struct.Class));
            returnObj = TabUtils.currentClassObj;
            innerClassesCount++;
        }else {
            report_error("Semanticka greska na liniji " + baseClassleft + " : [R84] Ime klase je vec definisano", null);
        }
        return returnObj;
    }

    public void countMethods(ScopeNode scope){

        switch(scope){
            case GLOBAL:
                globalFunctionsCount++;
                break;
            case CLASS: case ABSTRACT_CLASS:
                innerClassMethodsCount++;
                break;
        }
    }

    public void setMethodParams(Obj methodObj){

        methodObj.setLevel(TabUtils.formalParamCount);
        Tab.chainLocalSymbols(methodObj);
    }

    public void insertThisParam(ScopeNode scope, VarNode var){

        if(ScopeNode.CLASS.equals(scope) || ScopeNode.ABSTRACT_CLASS.equals(scope)){
            varProcessing("this", 888, TabUtils.currentClassObj.getType(), var);
        }
    }

    public Obj getDesignator(String name, int nameleft){

        Obj obj = Tab.find(name);

        if(Tab.noObj.equals(obj)){
            report_error("Semanticka greska na liniji " + nameleft + " : ime " + name + " nije deklarisano! ", null);
            return obj;
        }

        return obj;
    }

    public Obj getClassDesignator(String name, int nameleft){

        Obj result = Tab.noObj;
        Obj className = TabUtils.currentDesignatorObj;

        if(className.getType().getKind() != Struct.Class){
             report_error("Semanticka greska na liniji " + nameleft + " : ime " + className.getName() + " mora biti unutrasnja klasa! ", null);
             return result;
        }

        Obj classElement = className.getType().getMembersTable().searchKey(name);

        if(classElement == null){
           report_error("Semanticka greska na liniji " + nameleft + " : ime " + name + " nije deklarisano unutar klase! ", null);
        }else{

           TabUtils.currentDesignatorObj = classElement;
           result = classElement;
        }

        return result;
    }

    public Struct getRefArray(Struct type, Struct expr, int exprleft){

       Struct result = Tab.noType;

       if(Tab.intType.equals(expr)){

         objectCreationCount++;
         result = new Struct(Struct.Array, type);
       }
       else {
          report_error("Semanticka greska na liniji " + exprleft + " : broj elemenata niza mora biti tipa int! ", null);
       }

       return result;
    }

    public Struct newTypeStat(Struct type, int typeleft){

        Struct result = Tab.noType;

        if(type.getKind() == Struct.Class){
           result = type;
        } else {
           report_error("Semanticka greska na liniji " + typeleft + " : unut. klasa mora biti koriscenja za new iskaz! ", null);
        }

        return result;
    }

    public Struct mulopFactor(Struct factorLeft, Struct factorRight, int line){

        Struct result = Tab.noType;

        if(factorLeft.getKind() != Struct.Int || factorRight.getKind() != Struct.Int){
             report_error("Semanticka greska na liniji " + line + " : izrazi pri operacijama *, / i % moraju biti tipa int! ", null);
        }else {
            result = Tab.intType;
        }

        return result;
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null)
	//	log.info(s.toString() + " " + s.value.toString());
	return s;
:}


init with {:
	 Tab.init(); // Universe scope

	 // setujemo Bool i String tipove u universe scope
	 Scope universe = Tab.currentScope();

	 universe.addToLocals(new Obj(Obj.Type, "bool", TabUtils.boolType));
	 universe.addToLocals(new Obj(Obj.Type, "string", TabUtils.stringType));
:}

action code {:

    ScopeNode scope = ScopeNode.GLOBAL;
    VarNode var = VarNode.GLOBAL_VAR;
    ConstNode con = ConstNode.NUMBER;
:}

terminal PROG, CONST, VOID, ABSTRACT, CLASS, EXTENDS, NEW;
terminal IF, ELSE, WHILE, PRINT, READ, BREAK, RETURN;
terminal PLUS, MINUS, TIMES, DIV, MOD;
terminal ISEQUAL, ISNOTEQUAL, ISGREATER, ISGREATEREQ, ISLESS, ISLESSEQ;
terminal OR, AND;
terminal EQUAL, INCREMENT, DECREMENT;
terminal LBRACE, RBRACE, RSQUARE, LSQUARE, LPAREN, RPAREN, DOT, COMMA, SEMI;

terminal Integer NUMBER ;
terminal Boolean BOOLVAL ;
terminal Character CHARCONST ;
terminal String STRING_LITERAL ;
terminal String IDENT ;

non terminal Program, GlobalDeclaration, GlobalDeclList, GlobalDeclPart;
non terminal ConstDecl, ConstDeclSemi, ConstDeclList, ConstDeclPart;
non terminal VarDecl, VarList, VarPart, VarPart_Comma_Recovery, VarPart_Semi_Recovery;
non terminal ClassDecl, AbsClass;
non terminal ClassDefinition, ClassVarList, ClassVarPart, ClassVarList_RBRACE_Recovery;
non terminal ClassMethodDecl, ClassMethodList, ClassMethodPart;
non terminal C_VarDecl, C_VarList;
non terminal MethodDecl, MethodDeclList, MethodDeclPart;
non terminal MethodVarDeclList, LocalVarDecl_Semi_Recovery, LocalVarDecl_Lbrace_Recovery;
non terminal M_VarList;
non terminal FormPars, ActualPars, ActualParamList, ActualPars_Rparen_Recovery;
non terminal FormPars_Recovery, FormalParamDecl_Comma_Recovery, FormalParamDecl_Rparen_Recovery;
non terminal FormalParamType;
non terminal AllStatements, StatementList, Statement;
non terminal Unmatched, Matched, WhileBreak;
non terminal MethodVarDeclLB_Recovery;

non terminal Addop, Mulop, Relop;

non terminal Obj ProgBegin, ClassExtendsLB_Recovery, MethodName;
non terminal Obj Designator, DesignatorList, DesignatorPart, ExprInSquaresRS_Recovery;
non terminal Struct Type, MethodRetType, Term, Term_list, Expr, Factor, Factor_list;

non terminal Boolean Brace_condition, Condition, CondTermOR, CondTerm, CondFactAND, CondFact;
non terminal Struct Dodela;
non terminal FuncCalls, ProgramFunc;

Program ::= PROG ProgBegin:p GlobalDeclaration LBRACE MethodDecl RBRACE
            {:
                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :}
            |
            PROG ProgBegin:p GlobalDeclaration LBRACE  RBRACE
            {:
                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :};

ProgBegin ::=  IDENT:id
                {:
                    RESULT = Tab.insert(Obj.Prog, id, Tab.noType);
                    Tab.openScope();
                :};

GlobalDeclaration ::=  GlobalDeclList
                        |
                       /* epsilon */;

GlobalDeclList ::= GlobalDeclList GlobalDeclPart
				   |
				   GlobalDeclPart ;


GlobalDeclPart ::=  ConstDecl
                    |
                    VarDecl
                    |
                    ClassDecl;


Type ::= IDENT:typeName
         {:

            Obj typeNode = Tab.find(typeName);
            if (typeNode.equals(Tab.noObj)) {

                parser.report_error("Semanticka greska - Nije pronadjen tip '" + typeName + "' u tabeli simbola", null);
                RESULT = Tab.noType;
            }
            else {
                if (Obj.Type == typeNode.getKind()) {
                    RESULT = typeNode.getType();
                }
                else {
                    parser.report_error("Greska na liniji " + typeNameleft + " : Ime " + typeName + " ne predstavlja tip ", null);
                    RESULT = Tab.noType;
                }
            }

        :};


// ---------------------- CONST DECL --------------------------

ConstDeclSemi ::= CONST Type:tip
                  {:
                     TabUtils.currentVarType = tip;
                  :}
                  ConstDeclList;


ConstDecl ::= ConstDeclSemi SEMI
              |
              error SEMI:e
              {:
                 parser.report_error("Sintaksna greska prilikom definicije glob. konstante na liniji "+ eleft + " izvrsen oporavak do ; ", null);
              :};

ConstDeclList ::= ConstDeclList COMMA ConstDeclPart
                     |
                  ConstDeclPart
                     |
                  error COMMA:l
                   {:
                      parser.report_error("Sintaksna greska prilikom definicije glob. konstante na liniji " + lleft + " izvrsen oporavak do , ", null);
                   :};

ConstDeclPart ::= IDENT:id EQUAL NUMBER:num
                  {:
                    con = ConstNode.NUMBER;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL CHARCONST:ch
                  {:
                    con = ConstNode.CHAR;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL BOOLVAL:bool
                  {:
                    con = ConstNode.BOOL;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :}
                  |
                  IDENT:id EQUAL STRING_LITERAL:str
                  {:
                    con = ConstNode.STRING;
                    parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                  :};

// ---------------------- VAR DECL --------------------------

VarDecl ::= Type:typeName
            {:
                TabUtils.currentVarType = typeName;
                var = VarNode.GLOBAL_VAR;
            :}
            VarList;

VarList ::= VarPart_Comma_Recovery VarList
            |
            VarPart_Semi_Recovery;

VarPart_Semi_Recovery ::= VarPart SEMI
                          |
                          error SEMI:l
                          {:
                            parser.report_error("Sintaksna greska prilikom definicije glob. prom. na liniji " + lleft + " izvrsen oporavak do ;", null);
                          :};

VarPart_Comma_Recovery ::= VarPart COMMA
                           |
                           error COMMA:cl
                           {:
                               parser.report_error("Sintaksna greska prilikom definicije glob. prom. na liniji " + clleft + " izvrsen oporavak do ,", null);
                           :};

VarPart ::= IDENT:id
            {:
                parser.varProcessing(id, idleft, TabUtils.currentVarType, var);
            :}
            |
            IDENT:id LSQUARE RSQUARE
            {:
                VarNode arrayVar = VarNode.varToArray(var);
                parser.varProcessing(id, idleft, TabUtils.currentVarType, arrayVar);
            :};


// ---------------------- CLASS DECL --------------------------


AbsClass ::=  CLASS
              {:
                 scope = ScopeNode.CLASS;
              :}
              |
              ABSTRACT CLASS
              {:
                 scope = ScopeNode.ABSTRACT_CLASS;
              :};

ClassDecl ::= AbsClass ClassExtendsLB_Recovery:classObj ClassDefinition
              {:

                 if(!Tab.noObj.equals(classObj)){

                    Tab.chainLocalSymbols(classObj.getType());
                    parser.report_info("Nadjena klasa na liniji " + classObjleft + " | " + TabUtils.printObj(classObj), null);
                 }

                 Tab.closeScope();
                 scope = ScopeNode.GLOBAL;
              :};

ClassExtendsLB_Recovery ::= IDENT:baseClass EXTENDS IDENT:superClass LBRACE
                            {:
                                RESULT = parser.classProcessing(baseClass, baseClassleft, superClass, superClassleft);
                                Tab.openScope();
                            :}
                            |
                            IDENT:baseClass LBRACE
                            {:
                                RESULT = parser.classProcessing(baseClass, baseClassleft, null, -1);
                                Tab.openScope();
                            :}
                            |
                            error LBRACE:l
                            {:
                                parser.report_error("Sintaksna greska prilikom prosirenja nadklase na liniji " + lleft + " izvrsen oporavak do {", null);

                                RESULT = Tab.noObj;
                                Tab.openScope();
                            :};

ClassDefinition ::= ClassVarList_RBRACE_Recovery
                    |
                    ClassMethodDecl RBRACE
                    |
                    RBRACE;

ClassVarList_RBRACE_Recovery ::= ClassVarList ClassMethodDecl RBRACE
                                 |
                                 ClassVarList RBRACE
                                 |
                                 error RBRACE:l
                                 {:
                                    parser.report_error("Sintaksna greska prilikom definicije atributa klase na liniji " + lleft + " izvrsen oporavak do }", null);
                                 :};

ClassVarList ::= ClassVarList ClassVarPart
                 |
                 ClassVarPart;

ClassVarPart ::= C_VarDecl SEMI
                 |
                 error SEMI:l
                 {:
                     parser.report_error("Sintaksna greska prilikom definicije atributa klase na liniji " + lleft + " izvrsen oporavak do ;", null);
                 :};

C_VarDecl ::=  Type:typeName
              {:
                 TabUtils.currentVarType = typeName;
                 var = VarNode.CLASS_VAR;
              :}
              C_VarList;

C_VarList ::= C_VarList COMMA VarPart
              |
              VarPart;

ClassMethodDecl ::= LBRACE ClassMethodList RBRACE;

ClassMethodList ::= ClassMethodList ClassMethodPart
                    |
                    ClassMethodPart;

ClassMethodPart ::= MethodDeclPart;


// ---------------------- METHOD DECL --------------------------


MethodDecl ::= MethodDeclList;

MethodDeclList ::= MethodDeclList MethodDeclPart
                   |
                   MethodDeclPart;

MethodRetType ::= Type:retType
                  {:
                        TabUtils.isVoid = Tab.noType.equals(retType) ? true : false;
                        RESULT = retType;
                  :}
                  |
                  VOID
                  {:
                       TabUtils.isVoid = true;
                       RESULT = Tab.noType;
                  :};

MethodName ::= MethodRetType:retType IDENT:methName
                {:
                    if(methName.equals("main")) {
                        TabUtils.hasMainFunc = true;
                    }

                    RESULT = Tab.insert(Obj.Meth, methName, retType);
                    TabUtils.currentMethodObj = RESULT;
                    Tab.openScope();

                    var = VarNode.METHOD_FORMAL_VAR;
                    parser.insertThisParam(scope, var);
                :};

MethodVarDeclLB_Recovery ::= MethodVarDeclList
                             {:

                             :}
                             |
                             LBRACE
                             {:

                             :};

MethodDeclPart ::= MethodName:methName LPAREN FormPars_Recovery MethodVarDeclLB_Recovery AllStatements RBRACE
                   {:

                      parser.countMethods(scope);

                      parser.setMethodParams(methName);

                      TabUtils.resetMethodsFlags();

                      Tab.closeScope();
                   :}
                   |
                   ABSTRACT MethodName:methName LPAREN FormPars_Recovery SEMI
                   {:
                     if(!scope.equals(ScopeNode.ABSTRACT_CLASS)){
                         parser.report_error("Semanticka greska - apstraktna metoda deklarisana van apstraktne klase na liniji " + methNameleft, null);
                     }

                     parser.countMethods(scope);

                     parser.setMethodParams(methName);

                     TabUtils.resetMethodsFlags();

                     Tab.closeScope();
                   :};





MethodVarDeclList ::= LocalVarDecl_Semi_Recovery MethodVarDeclList
                      |
                      LocalVarDecl_Lbrace_Recovery;


LocalVarDecl_Semi_Recovery ::= Type:typeName
                               {:
                                   TabUtils.currentVarType = typeName;
                               :}
                               M_VarList SEMI
                               |
                               error SEMI:l
                               {:
                                    parser.report_error("Sintaksna greska prilikom definicije lokalnih prom. metode na liniji " + lleft + " izvrsen oporavak do ;", null);
                               :};


LocalVarDecl_Lbrace_Recovery ::= LocalVarDecl_Semi_Recovery LBRACE
                                 |
                                 error LBRACE:l
                                 {:
                                     parser.report_error("Sintaksna greska prilikom deklaracije lokalnih prom. na liniji " + lleft + " izvrsen oporavak do {", null);
                                 :};

M_VarList ::= M_VarList COMMA VarPart
              |
              VarPart;


// ---------------------- FORM PARAMS --------------------------

FormPars_Recovery ::= FormPars
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :}
                      |
                      RPAREN
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :};



FormPars ::= FormalParamDecl_Comma_Recovery FormPars
					|
			 FormalParamDecl_Rparen_Recovery;

FormalParamDecl_Comma_Recovery ::= FormalParamType VarPart COMMA
                                   |
                                   error COMMA:l
                                   {:
                                       parser.report_error("Sintaksna greska prilikom deklaracije formalnih prom na liniji " + lleft + " izvrsen oporavak do ,", null);
                                   :};

FormalParamDecl_Rparen_Recovery ::= FormalParamType VarPart RPAREN
                                    {:

                                    :}
                                    |
                                    error RPAREN:l
                                    {:
                                        parser.report_error("Sintaksna greska prilikom deklaracije formalnih prom na liniji " + lleft + " izvrsen oporavak do )", null);
                                    :};

FormalParamType ::= Type:typeName
                    {:
                        TabUtils.currentVarType = typeName;
                    :};


// ---------------------- STATEMENTS --------------------------


AllStatements ::= StatementList
                        |
                     /* epsilon */;

StatementList ::= StatementList Statement
				  |
				  Statement;

Statement ::= Matched | Unmatched ;

WhileBreak ::= WHILE {: TabUtils.inWhile = true; :};

Unmatched ::= IF Brace_condition:cond Statement
              {:

              :}
              |
              IF Brace_condition:cond Matched ELSE Unmatched
              {:

              :}
              |
              WhileBreak Brace_condition:cond Unmatched
              {:
                  TabUtils.inWhile = false;
              :};


Matched ::= Designator:dest EQUAL Dodela:d
            {:

            :}
            |
            Designator:dest INCREMENT SEMI
            {:

            :}
            |
            Designator:dest DECREMENT SEMI
            {:

            :}
            |
            FuncCalls
            |
            IF Brace_condition:cond Matched ELSE Matched
            {:

            :}
            |
            WhileBreak Brace_condition:cond Matched
            {:
                TabUtils.inWhile = false;
            :}
            |
            RETURN Expr:t SEMI
            {:
                TabUtils.returnFound = true;
            :}
            |
            RETURN SEMI
            {:
                TabUtils.returnFound = true;
            :}
            |
            BREAK:b SEMI
            {:
                if(!TabUtils.inWhile){
                    parser.report_error("Semanticka greska na liniji " + bleft + " : break iskaz se poziva van while petlje", null);
                }
            :}
            |
            LBRACE
            {:
                parser.statementsCount++;
            :}
            AllStatements RBRACE;


Brace_condition ::= LPAREN Condition:c RPAREN
                    {:
                        RESULT = c;
                    :}
                    |
                    error RPAREN:l
                    {:
                        parser.report_error("Sintaksna greska logickog izraza unutar if ili while konstrukcije na liniji " + lleft + " izvrsen oporavak do prvog znaka )",null);
                        TabUtils.conditionError = true;
                        RESULT = false;
                    :};

Dodela ::= 	Expr:e SEMI
            {:
                /*
                if (parser.isInMain() && !parser.indeksGreska()) parser.incIskaza ();
                parser.resetIndeksGreska();

                RESULT = e;
                */
            :}
            |
            error SEMI:l
            {:

                parser.report_error("Sintaksna greska prilikom dodele vrednosti na liniji " + lleft + " izvrsen oporavak do ;",null);
                // RESULT = Tab.noType;

            :};

ProgramFunc ::= Designator:d LPAREN
                {:

                     // broji se funkcija i u slucaju da se desi greska u njenim argumentima
                     if(TabUtils.hasMainFunc && TabUtils.isSingleName) {
                         parser.functionCallsInMainCount++;
                     }
                :};

FuncCalls ::= ProgramFunc ActualPars_Rparen_Recovery SEMI
              {:

              :}
              |
              READ LPAREN Designator RPAREN SEMI
              {:
                  if(TabUtils.hasMainFunc) {
                     parser.functionCallsInMainCount++;
                  }
              :}
              |
              PRINT LPAREN Expr RPAREN SEMI
              {:
                    if(TabUtils.hasMainFunc) {
                       parser.functionCallsInMainCount++;
                    }
              :}
              |
              PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
              {:
                    if(TabUtils.hasMainFunc) {
                       parser.functionCallsInMainCount++;
                    }
              :}
              |
              error SEMI:l
              {:
                  parser.report_error("Sintaksna greska prilikom poziva funkcije na liniji " + lleft + " izvrsen oporavak do ;",null);
              :};

Condition ::= CondTermOR:cor {: RESULT = cor; :};

CondTermOR ::= CondTermOR:cor OR CondTerm:ct
               {:
                    RESULT = (ct || cor) ? true : false;
               :}
               |
               CondTerm:c
               {:
                    RESULT = c;
               :};

CondTerm ::= CondFactAND:cand {: RESULT = cand; :};

CondFactAND ::= CondFactAND:cand AND CondFact:cf
                {:
                    RESULT = (cf && cand) ? true : false;
                :}
                |
                CondFact:cf
                {:
                     RESULT = cf;
                :};

CondFact ::= Expr:exp1 Relop Expr:exp2
             {:

             :}
             |
             Expr:exp1
             {:
                  // RESULT = exp1;
             :};


Expr ::= Term_list:tl
         {:
            // RESULT = tl;
         :}
         |
         MINUS Term_list:tl
         {:

         :};

Term_list ::= Term_list:t Addop Term:r
              {:

              :}
              |
              Term:trm
              {:

              :};

Term ::= Factor_list:fl
         {:
             RESULT = fl;
         :};

Factor_list ::= Factor_list:fl Mulop Factor:ff
                {:
                    RESULT = parser.mulopFactor(fl, ff, flleft);
                :}
                 |
                 Factor:f
                 {:
                     RESULT = f;
                 :};

Factor ::= NUMBER
           {:
              RESULT = Tab.intType;
           :}
           |
           CHARCONST
           {:
               RESULT = Tab.charType;
           :}
           |
           LPAREN Expr:e RPAREN
           {:
               RESULT = e;
           :}
           |
           BOOLVAL
           {:
               RESULT = TabUtils.boolType;
           :}
           |
           STRING_LITERAL
           {:
               RESULT = TabUtils.stringType;
           :}
           |
           NEW Type:id LSQUARE Expr:e RSQUARE
           {:
               RESULT = parser.getRefArray(id, e, eleft);
           :}
           |
           NEW Type:id
           {:
               parser.objectCreationCount++;
               RESULT =  parser.newTypeStat(id, idleft);
           :}
           |
           Designator:d
           {:
               RESULT = d.getType();
           :}
           |
           ProgramFunc ActualPars_Rparen_Recovery:lt
           {:
                         // TODO trebalo bi da postoji razlika izmendju factor dela i pozivanja funkcija
           :};

ActualPars_Rparen_Recovery ::= ActualPars RPAREN:lt
                               {:

                               :}
                               |
                               error RPAREN:l
                               {:
                                  parser.report_error("Sintaksna greska u listi parametara pri pozivu f-je na liniji " + lleft + " izvrsen oporavak do )",null);
                               :};


ActualPars ::= ActualParamList
			   |
			   /* epsilon */  ;

ActualParamList ::= ActualParamList COMMA Expr
					|
					Expr ;

Designator ::= IDENT:name
                {:
                    TabUtils.isSingleName = false;

                    TabUtils.currentDesignatorObj = parser.getDesignator(name, nameleft);
                :}
                DesignatorList:dsList
                {:
                    RESULT = dsList;
                :}
                |
                IDENT:name
                {:
                    TabUtils.isSingleName = true;

                    RESULT = parser.getDesignator(name, nameleft);
                :};

DesignatorList ::= DesignatorList DesignatorPart
                   |
                   DesignatorPart;

ExprInSquaresRS_Recovery ::= LSQUARE Expr:e RSQUARE
                             {:
                                  if(!Tab.intType.equals(e)){
                                    parser.report_error("Semanticka greska na liniji " + eleft + " : index niza mora biti tipa int! ", null);
                                  }
                             :}
                             |
                             error RSQUARE:l
                             {:
                                parser.report_error("Sintaksna greska izraza za index. niza na liniji " + lleft + " izvrsen oporavak do ]",null);
                             :};

DesignatorPart ::=  ExprInSquaresRS_Recovery:exSqr
                    {:
                        if(TabUtils.currentDesignatorObj.getType().getKind() != Struct.Array){

                            parser.report_error("Semanticka greska na liniji " + exSqrleft + " : nadjeni element mora biti tipa niz! ", null);
                            RESULT = Tab.noObj;
                        }
                        RESULT = TabUtils.currentDesignatorObj;
                    :}
                    |
                    DOT IDENT:name
                    {:
                         RESULT = parser.getClassDesignator(name, nameleft);
                    :};

Addop ::= PLUS
          |
          MINUS;

Mulop ::= TIMES
          |
          DIV
          |
          MOD;

Relop ::=     ISEQUAL
              |
              ISNOTEQUAL
              |
              ISGREATER
              |
              ISGREATEREQ
              |
              ISLESS
              |
              ISLESSEQ;

