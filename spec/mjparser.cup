package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;


parser code {:

	// counting declarations vars
	int globalPrimitiveVarsCount = 0;
	int globalArraysCount = 0;

    // counting definitions vars
	int globalFunctionsCount = 0;
	int innerClassesCount = 0;

    //
	int statementsCount = 0;
	int functionCallsInMainCount = 0;
	int objectCreationCount = 0;

	// inner classes vars
	int innerClassAttributesCount = 0;
	int innerClassMethodsCount = 0;
	int extendingClassesCount = 0;


	// error detection var
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        //report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

    /*
     * util functions
     */
     
     public Struct getType(String typeName, int typeNameleft) {
     
     	Obj typeNode = Tab.find(typeName);

        if (Tab.noObj.equals(typeNode)) {
            report_error(SemanticErrorDesc.S2_01.print(typeName), null);
            return Tab.noType;
        }
        
        if (Obj.Type != typeNode.getKind()) {
            report_error(SemanticErrorDesc.S2_02.print(typeNameleft, typeName), null);
            return Tab.noType;
        }
     
        return typeNode.getType();
     }

    public Obj constantProcessing(String id, int idleft, Struct type, ConstNode node) {

        Obj konstanta = Tab.find(id);

		// Vec definisana konstanta
        if (!Tab.noObj.equals(konstanta)) {
         	report_error(SemanticErrorDesc.S2_07.print(idleft, konstanta.getName()), null);
       		return konstanta;
        }

		// NUMBER
		if(ConstNode.NUMBER.equals(node)) {
			
			if(!Tab.intType.equals(type)) {
               report_error(SemanticErrorDesc.S2_03.print(idleft), null);
               return Tab.noObj;
            }
             
            konstanta = Tab.insert(Obj.Con, id, type);
            report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
            return konstanta;
		}
		
		// CHAR
		if(ConstNode.CHAR.equals(node)) {
			
			if(!Tab.charType.equals(type)) {
               report_error(SemanticErrorDesc.S2_04.print(idleft), null);
			   return Tab.noObj;
            } 
           
           konstanta = Tab.insert(Obj.Con, id, type);
           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
           return konstanta;
		}
		
		// BOOL
		if(ConstNode.BOOL.equals(node)) {
		
           if(!TabUtils.boolType.equals(type)) {
              report_error(SemanticErrorDesc.S2_05.print(idleft), null);
			  return Tab.noObj;
           }
           
           konstanta = Tab.insert(Obj.Con, id, type);
           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
           return konstanta;
		}
		
		// STRING
		if(ConstNode.STRING.equals(node)) {
		
		   if(!TabUtils.stringType.equals(type)) {
              report_error(SemanticErrorDesc.S2_06.print(idleft), null);
              return Tab.noObj;
           }
           
           konstanta = Tab.insert(Obj.Con, id, type);
           report_info("Nadjena konstanta na liniji " + idleft + " | " + TabUtils.printObj(konstanta), null);
           return konstanta;
		}
		
		report_info("Nije setovan ConstNode objekat metode constantProcessing", null);
        return konstanta;
    }

    public void varProcessing(String id, int idleft, Struct type, VarNode node) {

		// Provera tipa
        if(Tab.noType.equals(type)) {
           report_error(SemanticErrorDesc.S2_08.print(idleft), null);
           return;
        }

        Obj promenljiva = Tab.currentScope().findSymbol(id);

		// Provera da li je promenljiva vec definisana
        if(promenljiva != null && !Tab.noObj.equals(promenljiva)) {
            report_error(SemanticErrorDesc.S2_09.print(idleft, promenljiva.getName()), null);
        	return;
        }

		// GLOBAL_VAR
		if(VarNode.GLOBAL_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, type);
            globalPrimitiveVarsCount++;
            report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
		}

		// CLASS_VAR
		if(VarNode.CLASS_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Fld, id, type);
            if(!"this".equals(id)) {
                innerClassAttributesCount++;
                report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
            }
		}
		
		// METHOD_LOCAL_VAR
		if(VarNode.METHOD_LOCAL_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, type);
			report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
		}

		// METHOD_FORMAL_VAR
		if(VarNode.METHOD_FORMAL_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, type);
            setFormalParam(prom);
		}

		// GLOBAL_ARRAY_VAR
		if(VarNode.GLOBAL_ARRAY_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
            globalArraysCount++;
            report_info("Nadjena globalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
		}

		// CLASS_ARRAY_VAR
		if(VarNode.CLASS_ARRAY_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Fld, id, new Struct(Struct.Array, type));

            if(!"this".equals(id)) {

                innerClassAttributesCount++;
                report_info("Nadjeno polje unutrasnje klase na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
            }
		}

		// METHOD_LOCAL_ARRAY_VAR
		if(VarNode.METHOD_LOCAL_ARRAY_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
            report_info("Nadjena lokalna promenljiva na liniji " + idleft + " | " + TabUtils.printObj(prom), null);
		}

		// METHOD_FORMAL_ARRAY_VAR
		if(VarNode.METHOD_FORMAL_ARRAY_VAR.equals(node)) {
			
			Obj prom = Tab.insert(Obj.Var, id, new Struct(Struct.Array, type));
            setFormalParam(prom);
		}
    }

    public void setFormalParam(Obj formParam) {
           formParam.setFpPos(TabUtils.formalParamPosition++);
           
           // broje se svi koji nisu "this", this je prvi parametar na poziciji 0
           if(!formParam.getName().equals("this")) {
           		TabUtils.formalParamCount++;
           }
    }

    public Obj classProcessing(String className, int classNameleft) {

        Obj classObj = Tab.find(className);
        
         if(!Tab.noObj.equals(classObj)) {
            report_error(SemanticErrorDesc.S2_10.print(classNameleft), null);
            return Tab.noObj;
         }
        
        TabUtils.currentClassObj = Tab.insert(Obj.Type, className, new Struct(Struct.Class));

        innerClassesCount++;
        
        return TabUtils.currentClassObj;
    }

	/*
	 * Vezuju se klase dete roditelj i kopiraju se atributi klase roditelja u trenutno otvoreni opseg.
	 
	 * Pogledaj PP1_P9a.doc strana 2.
	 */
    public boolean linkingChildParentClasses(String parentClass, Obj childClassObj, int parentClassleft) {

        Obj parentClassObj = getParentClassObj(parentClass, parentClassleft);
        
        // Super klasa nije nadjena
        if(Tab.noObj.equals(parentClassObj)) {
			return false;			
		}
		
		// Povezujemo klase dete roditelj.
		childClassObj.getType().setElementType(parentClassObj.getType());
		
		// Za nadjenu superklasu, kopiraj sve nasledjene atribute u izvedenu klasu
		TabUtils.copyParentClassMembers(Obj.Fld);
		
		return true;
    }

    public Obj getParentClassObj(String parentClass, int parentClassleft) {
        
        if(parentClass == null) {
        	return Tab.noObj;
        }

        Obj parentClassObj = Tab.find(parentClass);
        
        if(Tab.noObj.equals(parentClassObj)) {

            report_error(SemanticErrorDesc.S2_11.print(parentClassleft), null);
            return Tab.noObj; 
        } 
        
        if(parentClassObj.getKind() != Obj.Type && !Tab.nullType.equals(parentClassObj.getType())){

            report_error(SemanticErrorDesc.S2_12.print(parentClassleft), null);
            return Tab.noObj;
        } 
        
        return parentClassObj;
    }

    public void countMethods(ScopeNode scope){
        switch(scope){
            case GLOBAL:
                globalFunctionsCount++;
                break;
            case CLASS: case ABSTRACT_CLASS:
                innerClassMethodsCount++;
                break;
        }
    }

    public void setMethodParams(Obj methodObj){

        methodObj.setLevel(TabUtils.formalParamCount);
        Tab.chainLocalSymbols(methodObj);
    }

    public void insertThisParam(ScopeNode scope, VarNode var) {

        if(ScopeNode.CLASS.equals(scope) || ScopeNode.ABSTRACT_CLASS.equals(scope)) {
            varProcessing("this", 888, TabUtils.currentClassObj.getType(), var);
        }
    }

    public Obj getDesignator(String name, int nameleft, ScopeNode scope) {

       if("this".equals(name) && ScopeNode.GLOBAL.equals(scope)) {
          report_error(SemanticErrorDesc.S2_41.print(nameleft), null);
          return Tab.noObj;
       }

       Obj obj = Tab.find(name);
		
	   if(Tab.noObj.equals(obj)) {
		   report_error(SemanticErrorDesc.S2_42.print(nameleft, name), null);
		   return Tab.noObj;
	   }
       return obj;
    }

    public Obj getClassDesignator(String name, int nameleft) {

        if(TabUtils.currentDesignatorObj.getType().getKind() != Struct.Class) {
             report_error(SemanticErrorDesc.S2_45.print(nameleft, TabUtils.currentDesignatorObj.getName()), null);
             return Tab.noObj;
        }

		Obj result = TabUtils.findMemberInClass(TabUtils.currentDesignatorObj, name);

        if(Tab.noObj.equals(result)) {
           report_error(SemanticErrorDesc.S2_46.print(nameleft, name), null);
           return Tab.noObj;
        }
       
        TabUtils.currentDesignatorObj = result;
        return result;
    }

    public Struct getRefArray(Struct type, Struct expr, int exprleft){

	   /*
       if(TabUtils.isAbstractClass()){

          report_error(SemanticErrorDesc.S2_37.print(exprleft), null);
          return Tab.noType;
       }
	   */

       if(Tab.intType.equals(expr)){

          objectCreationCount++;
          Struct result = new Struct(Struct.Array, type);
          return result;
       }
       
       report_error(SemanticErrorDesc.S2_38.print(exprleft), null);
       return Tab.noType;
    }

    public Struct newTypeStat(Struct type, int typeleft){

		/*
        if(TabUtils.isAbstractClass()){

          report_error(SemanticErrorDesc.S2_39.print(typeleft), null);
          return Tab.noType;
        }
        */

        if(type.getKind() == Struct.Class){
           return type;
        }

        report_error(SemanticErrorDesc.S2_40.print(typeleft), null);
        return Tab.noType;
    }

    public boolean isTermsStringCompatible(Struct termLeft, Struct termRight) {
    
        return (termLeft.getKind() == Struct.Array && termLeft.getElemType().getKind() == Struct.Char &&
                termRight.getKind() == Struct.Array && termRight.getElemType().getKind() == Struct.Char) ? true : false;
    }

    public Struct addopTerms(Struct termLeft, Struct termRight, int line, int op){

        if(!termLeft.compatibleWith(termRight)){
             report_error(SemanticErrorDesc.S2_33.print(line), null);
             return Tab.noType;
        }

        if(op == Code.add) {

           if(termLeft.getKind() == Struct.Int && termRight.getKind() == Struct.Int) {
              return Tab.intType;
           }
           
           if(isTermsStringCompatible(termLeft, termRight)){
               return TabUtils.stringType;
           }

           report_error(SemanticErrorDesc.S2_34.print(line), null);
           return Tab.noType;
        } 
        
		if (op == Code.sub) {

           if(termLeft.getKind() == Struct.Int && termRight.getKind() == Struct.Int) {
              return Tab.intType;
           } 
			
           report_error(SemanticErrorDesc.S2_35.print(line), null);
           return Tab.noType;
        }
        
        return Tab.noType;
    }

    public Struct mulopFactors(Struct factorLeft, Struct factorRight, int line) {

        if(factorLeft.getKind() != Struct.Int || factorRight.getKind() != Struct.Int){
           
            report_error(SemanticErrorDesc.S2_36.print(line), null);
        	return Tab.noType;
        }
        
        return Tab.intType;
    }

    public Struct minusTerm(Struct termList, int termlistleft) {

        if(termList.getKind() == Struct.Int) {
           return Tab.intType;
        }
        
        report_error(SemanticErrorDesc.S2_32.print(termlistleft), null);
        return Tab.noType;
    }

   public boolean checkActParamsType(Obj func, int funcleft) {

      boolean isOK = true;

      if(TabUtils.actualParams.size() != 0){

          Iterator<Struct> actualParams = TabUtils.actualParams.iterator();
          Iterator<Obj> formalParams = func.getLocalSymbols().iterator();
          int counter = 1;

          // preskacemo this parametar na 0 poziciji
          if(!Tab.noObj.equals(TabUtils.findVarInMethod(func, "this"))) {
              formalParams.next();
          }

          while(actualParams.hasNext() && formalParams.hasNext()) {
			  
              if(!TabUtils.assignableTo(actualParams.next(), formalParams.next().getType())) {

                  report_error(SemanticErrorDesc.S2_47.print(funcleft, counter), null);
                  isOK = false;
              }
              counter++;
          }
      }
      return isOK;
   }

    public Struct checkFunc(Obj func, int funcleft, ScopeNode scope) {

        if(func.getKind() != Obj.Meth){

             report_error(SemanticErrorDesc.S2_25.print(funcleft, func.getName()), null);
             return Tab.noType;
        }

        if(func.getLevel() != TabUtils.actualParams.size()){
          report_error(SemanticErrorDesc.S2_26.print(funcleft), null);
        }

        checkActParamsType(func, funcleft);

        // broji se funkcija
        if(TabUtils.hasMainFunc) {
           functionCallsInMainCount++;
        }

        if(ScopeNode.GLOBAL.equals(scope)) {
            report_info("Poziv globalne funkcije na liniji " + funcleft + " | " + TabUtils.printObj(func), null);
        } 
        
		if(ScopeNode.CLASS.equals(scope)) {
            report_info("Poziv metode un.klase na liniji " + funcleft + " | " + TabUtils.printObj(func), null);
        }
        return func.getType();
    }

    // dozvoljeno samo za uslove ge, gt, le, lt
    public boolean checkRefTypeOperator(Struct exp1, Struct exp2, int op) {
        return (exp1.isRefType() && exp2.isRefType() && op != 0 && op != 1) ? true : false;
    }

    public boolean condFactCheck(Struct exp1, Struct exp2, int exp1left, int op) {

        if(!exp1.compatibleWith(exp2)) {

           report_error(SemanticErrorDesc.S2_30.print(exp1left), null);
           return false;
        }

        if(checkRefTypeOperator(exp1, exp2, op)) {

           report_error(SemanticErrorDesc.S2_31.print(exp1left), null);
           return false;
        }
        
        return true;
    }

    public boolean condFactCheck(Struct exp, int expleft) {

        if(!TabUtils.boolType.equals(exp)) {

            report_error(SemanticErrorDesc.S2_48.print(expleft), null);
            return false;
        }

        return true;
    }

    public boolean checkBasicType(Struct e) {

        return ( TabUtils.stringType.equals(e) || Struct.Char == e.getKind() ||
                 TabUtils.boolType.equals(e)   || Struct.Int == e.getKind() )
                 ? true : false;
    }

    public boolean isAssignableType(Obj d) {
        return (Obj.Var == d.getKind() || Obj.Elem == d.getKind() || Obj.Fld == d.getKind() ) ? true : false;
    }
	
	public void checkPrint(Struct e, int eleft, Integer num) {

        if(!checkBasicType(e)) {
           report_error(SemanticErrorDesc.S2_29.print(eleft), null);
        }

        if(TabUtils.hasMainFunc) {
           functionCallsInMainCount++;
        }

		if(Struct.Int == e.getKind()) {
			if(num != null) {
               Code.loadConst(num);
            } else {
                Code.loadConst(5);
            }
            Code.put(Code.print);
		}

		if(Struct.Char == e.getKind()) {
			if(num != null) {
              Code.loadConst(num);
            } else {
               Code.loadConst(1);
            }
            Code.put(Code.bprint);
		}
    }

    public void checkRead(Obj d, int dleft) {

        if(!isAssignableType(d)) {
           report_error(SemanticErrorDesc.S2_27.print(dleft, d.getName()), null);
        }

        if(!checkBasicType(d.getType())){
            report_error(SemanticErrorDesc.S2_28.print(dleft), null);
        }

        if(TabUtils.hasMainFunc) {
            functionCallsInMainCount++;
        }

		if(Struct.Int == d.getType().getKind()) {
			Code.put(Code.read);
		}

		if(Struct.Char == d.getType().getKind()) {
			Code.put(Code.bread);
		}

        Code.store(d);
    }
    
    public void checkLenFunc(Struct e, int eleft) {
    	
    	if(Struct.Array == e.getKind()) {
    		Code.put(Code.arraylength); 
    	} else {
    		report_error(SemanticErrorDesc.S2_49.print(eleft), null);
    	}
    	
    	if(TabUtils.hasMainFunc) {
    		functionCallsInMainCount++;
    	}
    }

    public boolean checkEqualExpr(Obj d, Struct s, int dleft) {

        if(!isAssignableType(d)) {

           report_error(SemanticErrorDesc.S2_19.print(dleft, d.getName()), null);
           return false;
        }

        if(!TabUtils.assignableTo(d.getType(), s)){

            report_error(SemanticErrorDesc.S2_20.print(dleft), null);
            return false;
        }

        return true;
    }

    public boolean checkIncDecExpr(Obj d, int dleft, boolean isInc) {

        if(!isAssignableType(d)) {

           report_error(SemanticErrorDesc.S2_21.print(dleft, d.getName()), null);
           return false;
        }

        if(!Tab.intType.equals(d.getType())){

            report_error(SemanticErrorDesc.S2_22.print(dleft), null);
            return false;
        } 
        
		 Code.load(d);
		 Code.loadConst(1);
		
		 if(isInc) {
		    Code.put(Code.add);
		 } else {
		    Code.put(Code.sub);
		 }
		 Code.store(d);
        
        return true;
    }

    public void checkMainFunction(int mleft) {

        if(!Tab.noObj.equals(TabUtils.currentMethodObj) && "main".equals(TabUtils.currentMethodObj.getName())){

            if(!TabUtils.currentMethodObj.getType().equals(Tab.noType)) {

               report_error(SemanticErrorDesc.S2_15.print(mleft), null);
            }
        }
    }

    public void checkReturnStat(Struct exp, int expleft) {

        if(!TabUtils.currentMethodObj.getType().equals(exp)) {
            report_error(SemanticErrorDesc.S2_23.print(expleft), null);
        }
    }

    public boolean findMethodName(String methName, int methNameleft, ScopeNode scope) {

        boolean result = false;

        if(methName.equals("main") && ScopeNode.GLOBAL.equals(scope)) {
            TabUtils.hasMainFunc = true;
        }

		// TODO - razlika izmedju dupliranja imena metoda i override-ovanja metoda nadklase.

        Obj findedMeth = Tab.currentScope.findSymbol(methName);
        
        boolean overridingMethod = TabUtils.checkIfMethodNameExistsInParentClass(methName);

        if(findedMeth != null && !overridingMethod) {
            report_error(SemanticErrorDesc.S2_13.print(methNameleft), null);
            result = true;
        }

        return result;
    }

    public void checkReturnExp(String methName){

        if(!TabUtils.returnFound && !TabUtils.isVoid) {
            report_error(SemanticErrorDesc.S2_16.print(methName), null);
        }

        if(TabUtils.returnFound && TabUtils.isVoid) {
            report_error(SemanticErrorDesc.S2_17.print(methName), null);
        }
    }

    /**
    *    CODE GENERATION METHODS
    */

    public void setMethodAdrCode() {

        if(!TabUtils.isMethodExist) {
            TabUtils.currentMethodObj.setAdr(Code.pc);

            if("main".equals(TabUtils.currentMethodObj.getName())) {
                Code.mainPc = TabUtils.currentMethodObj.getAdr();
            }
        }
    }

    public void setMethodEnterCode() {

        Code.put(Code.enter);
        Code.put(TabUtils.currentMethodObj.getLevel());
        Code.put(Tab.currentScope().getnVars());
    }

    public void setMethodExitCode() {
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	//if (s != null && s.value != null)
	//	log.info(s.toString() + " " + s.value.toString());
	return s;
:}

init with {:
	 Tab.init(); // Universe scope

	 // setujemo Bool i String tipove u universe scope
	 Scope universe = Tab.currentScope();

	 universe.addToLocals(new Obj(Obj.Type, "bool", TabUtils.boolType));
	 universe.addToLocals(new Obj(Obj.Type, "string", TabUtils.stringType));
:}

action code {:

    ScopeNode scope = ScopeNode.GLOBAL;
    VarNode var = VarNode.GLOBAL_VAR;
    ConstNode con = ConstNode.NUMBER;
:}

terminal PROG, CONST, VOID, ABSTRACT, CLASS, EXTENDS, NEW;
terminal IF, ELSE, WHILE, PRINT, READ, BREAK, RETURN;
terminal PLUS, MINUS, TIMES, DIV, MOD;
terminal ISEQUAL, ISNOTEQUAL, ISGREATER, ISGREATEREQ, ISLESS, ISLESSEQ;
terminal OR, AND;
terminal EQUAL, INCREMENT, DECREMENT;
terminal LBRACE, RBRACE, RSQUARE, LSQUARE, LPAREN, RPAREN, DOT, COMMA, SEMI;

terminal Integer NUMBER ;
terminal Boolean BOOLVAL ;
terminal Character CHARCONST ;
terminal String STRING_LITERAL ;
terminal String IDENT ;
terminal LEN;

non terminal Program, GlobalDeclaration, GlobalDeclList, GlobalDeclPart;
non terminal ConstDecl, ConstDeclSemi, ConstDeclList, ConstDeclPart;
non terminal VarDecl, VarList, VarPart, VarPart_Comma_Recovery, VarPart_Semi_Recovery;
non terminal ClassDecl, AbsClass;
non terminal ClassDefinition, ClassVarList, ClassVarPart, ClassVarList_RBRACE_Recovery;
non terminal ClassMethodDecl, ClassMethodList, ClassMethodPart;
non terminal C_VarDecl, C_VarList;
non terminal MethodDecl, MethodDeclList, MethodDeclPart;
non terminal MethodVarDeclList, LocalVarDecl_Semi_Recovery, LocalVarDecl_Lbrace_Recovery;
non terminal M_VarList;
non terminal FormPars, ActualPars, ActualParamList, ActualPars_Rparen_Recovery;
non terminal FormPars_Recovery, FormalParamDecl_Comma_Recovery, FormalParamDecl_Rparen_Recovery;
non terminal FormalParamType;
non terminal AllStatements, StatementList, Statement;
non terminal Unmatched, Matched, WhileBreak;
non terminal MethodVarDeclLB_Recovery;

non terminal Integer Addop, Mulop, Relop;

non terminal Obj ProgBegin, ClassExtendsLB_Recovery, MethodName;
non terminal Obj Designator, DesignatorList, DesignatorPart, ExprInSquaresRS_Recovery, ProgramFunc;
non terminal Struct Type, MethodRetType, Term, Term_list, Expr, Factor, Factor_list;

non terminal Boolean Brace_condition, Condition, CondTermOR, CondTerm, CondFactAND, CondFact;
non terminal Struct Dodela;
non terminal FuncCalls;

Program ::= PROG ProgBegin:p GlobalDeclaration LBRACE MethodDecl RBRACE
            {:
                if(!TabUtils.hasMainFunc) {
                   parser.report_error(SemanticErrorDesc.S2_00.print(), null);
                }

                Code.dataSize = Tab.currentScope().getnVars();

                Tab.chainLocalSymbols(p);
                Tab.closeScope();
            :}
            |
            PROG ProgBegin:p GlobalDeclaration LBRACE  RBRACE
            {:
                Code.dataSize = Tab.currentScope().getnVars();

                Tab.chainLocalSymbols(p);
                parser.report_error(SemanticErrorDesc.S2_00.print(), null);
                Tab.closeScope();
            :};

ProgBegin ::=  IDENT:id
                {:
                    RESULT = Tab.insert(Obj.Prog, id, Tab.noType);
                    Tab.openScope();
                :};

GlobalDeclaration ::=  GlobalDeclList
                        |
                       /* epsilon */;

GlobalDeclList ::= GlobalDeclList GlobalDeclPart
				   |
				   GlobalDeclPart ;

GlobalDeclPart ::=  ConstDecl
                    |
                    VarDecl
                    |
                    ClassDecl;

Type ::= IDENT:typeName
         {:
            RESULT = parser.getType(typeName, typeNameleft);
        :};
        
// ---------------------- CONST DECL --------------------------

ConstDeclSemi ::= CONST Type:tip
                  {:
                     TabUtils.currentVarType = tip;
                  :}
                  ConstDeclList;

ConstDecl ::= ConstDeclSemi SEMI
              |
              error SEMI:e
              {:
                 parser.report_error(SintaxErrorDesc.S1_00.print(eleft), null);
              :};

ConstDeclList ::= ConstDeclList COMMA ConstDeclPart
                     |
                  ConstDeclPart
                     |
                  error COMMA:l
                   {:
                      parser.report_error(SintaxErrorDesc.S1_01.print(lleft), null);
                   :};

ConstDeclPart ::= IDENT:id EQUAL NUMBER:num
                  {:
                    con = ConstNode.NUMBER;
                    Obj konstanta = parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                    konstanta.setAdr(num.intValue());
                  :}
                  |
                  IDENT:id EQUAL CHARCONST:ch
                  {:
                    con = ConstNode.CHAR;
                    Obj konstanta = parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                    konstanta.setAdr(ch.charValue());
                  :}
                  |
                  IDENT:id EQUAL BOOLVAL:bool
                  {:
                    con = ConstNode.BOOL;
                    Obj konstanta = parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                    konstanta.setAdr((bool == true) ? 1 : 0);
                  :}
                  |
                  IDENT:id EQUAL STRING_LITERAL:str
                  {:
                    con = ConstNode.STRING;
                    Obj konstanta = parser.constantProcessing(id, idleft, TabUtils.currentVarType, con);

                    //konstanta.setAdr(str.length());
                    //Code.load(konstanta);

                    // 1. get last free address from data stack
                    // 2. set adr to Obj object
                    // 3. push lenght of string to data stack
                    // 4. push each char from string to data stack
                    // 5. put string address to global hashmap for reuse
                  :};

// ---------------------- VAR DECL --------------------------

VarDecl ::= Type:typeName
            {:
                TabUtils.currentVarType = typeName;
                var = VarNode.GLOBAL_VAR;
            :}
            VarList;

VarList ::= VarPart_Comma_Recovery VarList
            |
            VarPart_Semi_Recovery;

VarPart_Semi_Recovery ::= VarPart SEMI
                          |
                          error SEMI:l
                          {:
                            parser.report_error(SintaxErrorDesc.S1_02.print(lleft), null);
                          :};

VarPart_Comma_Recovery ::= VarPart COMMA
                           |
                           error COMMA:cl
                           {:
                               parser.report_error(SintaxErrorDesc.S1_03.print(clleft), null);
                           :};

VarPart ::= IDENT:id
            {:
                parser.varProcessing(id, idleft, TabUtils.currentVarType, var);
            :}
            |
            IDENT:id LSQUARE RSQUARE
            {:
                VarNode arrayVar = VarNode.varToArray(var);
                parser.varProcessing(id, idleft, TabUtils.currentVarType, arrayVar);
            :};

// ---------------------- CLASS DECL --------------------------

AbsClass ::=  CLASS
              {:
                 scope = ScopeNode.CLASS;
              :}
              |
              ABSTRACT CLASS
              {:
                 scope = ScopeNode.ABSTRACT_CLASS;
              :};

ClassDecl ::= AbsClass ClassExtendsLB_Recovery:classObj ClassDefinition
              {:

                 if(!Tab.noObj.equals(classObj)){

                    Tab.chainLocalSymbols(classObj.getType());
                    
                    TabUtils.repairThisParameter();

                    parser.report_info("Nadjena klasa na liniji " + classObjleft + " | " + TabUtils.printObj(classObj), null);
                 }

                 Tab.closeScope();
                 
                 TabUtils.resetClassFlags();

                 scope = ScopeNode.GLOBAL;
              :};

ClassExtendsLB_Recovery ::= IDENT:childClass EXTENDS IDENT:parentClass LBRACE
                            {:
                                RESULT = parser.classProcessing(childClass, childClassleft);
                                
                                Tab.openScope();

                                boolean isLinkingSuccessful = parser.linkingChildParentClasses(parentClass, RESULT, parentClassleft);
                                
                                if(isLinkingSuccessful) {
                                	parser.extendingClassesCount++;
                                }
                            :}
                            |
                            IDENT:childClass LBRACE
                            {:
                                RESULT = parser.classProcessing(childClass, childClassleft);

                                Tab.openScope();
                            :}
                            |
                            error LBRACE:l
                            {:
                                parser.report_error(SintaxErrorDesc.S1_04.print(lleft), null);

                                RESULT = Tab.noObj;
                                Tab.openScope();
                            :};

ClassDefinition ::= ClassVarList_RBRACE_Recovery
                    |
                    ClassMethodDecl RBRACE
                    |
                    RBRACE;

ClassVarList_RBRACE_Recovery ::= ClassVarList ClassMethodDecl RBRACE
                                 |
                                 ClassVarList
                                 {:
                                 	TabUtils.copyParentClassMembers(Obj.Meth);
                                 :}
                                 RBRACE
                                 |
                                 error RBRACE:l
                                 {:
                                    parser.report_error(SintaxErrorDesc.S1_05.print(lleft), null);
                                 :};

ClassVarList ::= ClassVarList ClassVarPart
                 |
                 ClassVarPart;

ClassVarPart ::= C_VarDecl SEMI
                 |
                 error SEMI:l
                 {:
                     parser.report_error(SintaxErrorDesc.S1_06.print(lleft), null);
                 :};

C_VarDecl ::=  Type:typeName
              {:
                 TabUtils.currentVarType = typeName;
                 var = VarNode.CLASS_VAR;
              :}
              C_VarList;

C_VarList ::= C_VarList COMMA VarPart
              |
              VarPart;

ClassMethodDecl ::= LBRACE:l 
					{: 
						TabUtils.copyParentClassMembers(Obj.Meth); 
						
						// Vezu se atributi klase za currentClassObj, da bi mogao da se koristi this u metodama.
						Tab.chainLocalSymbols(TabUtils.currentClassObj.getType());						
					:} 
					ClassMethodList RBRACE;

ClassMethodList ::= ClassMethodList ClassMethodPart
                    |
                    ClassMethodPart;

ClassMethodPart ::= MethodDeclPart;

// ---------------------- METHOD DECL --------------------------

MethodDecl ::= MethodDeclList;

MethodDeclList ::= MethodDeclList MethodDeclPart
                   |
                   MethodDeclPart;

MethodRetType ::= Type:retType
                  {:
                        TabUtils.isVoid = Tab.noType.equals(retType) ? true : false;
                        RESULT = retType;
                  :}
                  |
                  VOID
                  {:
                       TabUtils.isVoid = true;
                       RESULT = Tab.noType;
                  :};

MethodName ::= MethodRetType:retType IDENT:methName
                {:
                    TabUtils.isMethodExist = parser.findMethodName(methName, methNameleft, scope);

                    RESULT = Tab.insert(Obj.Meth, methName, retType);

                    TabUtils.currentMethodObj = RESULT;

                    Tab.openScope();

                    var = VarNode.METHOD_FORMAL_VAR;
                    
                    parser.insertThisParam(scope, var);
                :};

MethodDeclPart ::= MethodName:methName LPAREN FormPars_Recovery MethodVarDeclLB_Recovery AllStatements RBRACE
                   {:

                      if(!TabUtils.isMethodExist) {

                          parser.countMethods(scope);
                          parser.checkReturnExp(methName.getName());
                      }

                      parser.setMethodParams(methName);

                      TabUtils.resetMethodsFlags();

                      parser.setMethodExitCode();

                      Tab.closeScope();
                   :}
                   |
                   ABSTRACT MethodName:methName LPAREN FormPars_Recovery SEMI
                   {:
                     if(!scope.equals(ScopeNode.ABSTRACT_CLASS)){
                         parser.report_error(SemanticErrorDesc.S2_18.print(methNameleft), null);
                     }

                    // TabUtils.hasAbstractMethod = true;

                     // ne broji se posto su abstraktne metode, deklaracije a ne definicije
                     // parser.countMethods(scope);

                     if(!TabUtils.isMethodExist) {
                         parser.checkReturnExp(methName.getName());
                         parser.setMethodParams(methName);
                     }

                     TabUtils.resetMethodsFlags();

                     parser.setMethodExitCode();

                     Tab.closeScope();
                   :};

MethodVarDeclLB_Recovery ::= MethodVarDeclList:m
                             {:
                                  parser.checkMainFunction(mleft);
                                  parser.setMethodAdrCode();
                                  parser.setMethodEnterCode();
                             :}
                             |
                             LBRACE:l
                             {:
                                  parser.checkMainFunction(lleft);
                                  parser.setMethodAdrCode();
                                  parser.setMethodEnterCode();
                             :};

MethodVarDeclList ::= LocalVarDecl_Semi_Recovery MethodVarDeclList
                      |
                      LocalVarDecl_Lbrace_Recovery;

LocalVarDecl_Semi_Recovery ::= Type:typeName
                               {:
                                   TabUtils.currentVarType = typeName;
                               :}
                               M_VarList SEMI
                               |
                               error SEMI:l
                               {:
                                    parser.report_error(SintaxErrorDesc.S1_07.print(lleft), null);
                               :};

LocalVarDecl_Lbrace_Recovery ::= LocalVarDecl_Semi_Recovery LBRACE
                                 |
                                 error LBRACE:l
                                 {:
                                     parser.report_error(SintaxErrorDesc.S1_08.print(lleft), null);
                                 :};

M_VarList ::= M_VarList COMMA VarPart
              |
              VarPart;

// ---------------------- FORM PARAMS --------------------------

FormPars_Recovery ::= FormPars
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :}
                      |
                      RPAREN
                      {:
                          var = VarNode.METHOD_LOCAL_VAR;
                      :};

FormPars ::= FormalParamDecl_Comma_Recovery FormPars
					|
			 FormalParamDecl_Rparen_Recovery;

FormalParamDecl_Comma_Recovery ::= FormalParamType VarPart COMMA
                                   |
                                   error COMMA:l
                                   {:
                                       parser.report_error(SintaxErrorDesc.S1_09.print(lleft), null);
                                   :};

FormalParamDecl_Rparen_Recovery ::= FormalParamType VarPart RPAREN
                                    {:
										
                                    :}
                                    |
                                    error RPAREN:l
                                    {:
                                        parser.report_error(SintaxErrorDesc.S1_10.print(lleft), null);
                                    :};

FormalParamType ::= Type:typeName
                    {:
                        TabUtils.currentVarType = typeName;
                    :};

// ---------------------- STATEMENTS --------------------------

AllStatements ::= StatementList
                        |
                     /* epsilon */;

StatementList ::= StatementList Statement
				  |
				  Statement;

Statement ::= Matched | Unmatched ;

WhileBreak ::= WHILE {: TabUtils.inWhile = true; :};

Unmatched ::= IF Brace_condition:cond Statement
              {:

              :}
              |
              IF Brace_condition:cond Matched ELSE Unmatched
              {:

              :}
              |
              WhileBreak Brace_condition:cond Unmatched
              {:
                  TabUtils.inWhile = false;
              :};

Matched ::= Designator:dest EQUAL Dodela:d
            {:
                 boolean isOK = parser.checkEqualExpr(dest, d, destleft);

                 if(isOK) {
                    Code.store(dest);
                 }
            :}
            |
            Designator:dest INCREMENT SEMI
            {:
                  parser.checkIncDecExpr(dest, destleft, true);
            :}
            |
            Designator:dest DECREMENT SEMI
            {:
                  parser.checkIncDecExpr(dest, destleft, false);
            :}
            |
            FuncCalls
            |
            IF Brace_condition:cond Matched ELSE Matched
            {:

            :}
            |
            WhileBreak Brace_condition:cond Matched
            {:
                TabUtils.inWhile = false;
            :}
            |
            RETURN Expr:t SEMI
            {:
                TabUtils.returnFound = true;
                parser.checkReturnStat(t, tleft);

                Code.put(Code.exit);
                Code.put(Code.return_);
            :}
            |
            RETURN:r SEMI
            {:
                TabUtils.returnFound = true;
                parser.checkReturnStat(Tab.noType, rleft);

                Code.put(Code.exit);
                Code.put(Code.return_);
            :}
            |
            BREAK:b SEMI
            {:
                if(!TabUtils.inWhile) {
                    parser.report_error(SemanticErrorDesc.S2_24.print(bleft), null);
                }
            :}
            |
            LBRACE
            {:
                parser.statementsCount++;
            :}
            AllStatements RBRACE;

Brace_condition ::= LPAREN Condition:c RPAREN
                    {:
                        RESULT = c;
                    :}
                    |
                    error RPAREN:l
                    {:
                        parser.report_error(SintaxErrorDesc.S1_11.print(lleft), null);
                        TabUtils.conditionError = true;
                        RESULT = false;
                    :};

Dodela ::= 	Expr:e SEMI
            {:
                 RESULT = e;
            :}
            |
            error SEMI:l
            {:
                parser.report_error(SintaxErrorDesc.S1_12.print(lleft), null);
                RESULT = Tab.noType;
            :};

FuncCalls ::= READ LPAREN Designator:d RPAREN SEMI
              {:
                  parser.checkRead(d, dleft);
              :}
              |
              PRINT LPAREN Expr:e RPAREN SEMI
              {:
                   parser.checkPrint(e, eleft, null);
              :}
              |
              PRINT LPAREN Expr:e COMMA NUMBER:n RPAREN SEMI
              {:
                    parser.checkPrint(e, eleft, n);
              :}
              |
              LEN LPAREN Expr:e RPAREN SEMI
              {:
              		parser.checkLenFunc(e, eleft);
              :}
              |
              ProgramFunc:func ActualPars_Rparen_Recovery:ap SEMI
              {:
                   RESULT = parser.checkFunc(func, funcleft, scope);
              :}
              |
              error SEMI:l
              {:
                  parser.report_error(SintaxErrorDesc.S1_13.print(lleft), null);
              :};

ProgramFunc ::= Designator:d LPAREN
                {:
                     TabUtils.actualParamCount = 0;
                     TabUtils.actualParams = new ArrayList<Struct>();
                     RESULT = d;
                :};

Condition ::= CondTermOR:cor {: RESULT = cor; :};

CondTermOR ::= CondTermOR:cor OR CondTerm:ct
               {:
                    RESULT = (ct || cor) ? true : false;
               :}
               |
               CondTerm:c
               {:
                    RESULT = c;
               :};

CondTerm ::= CondFactAND:cand {: RESULT = cand; :};

CondFactAND ::= CondFactAND:cand AND CondFact:cf
                {:
                    RESULT = (cf && cand) ? true : false;
                :}
                |
                CondFact:cf
                {:
                     RESULT = cf;
                :};

CondFact ::= Expr:exp1 Relop:op Expr:exp2
             {:
                  RESULT = parser.condFactCheck(exp1, exp2, exp1left, op);
             :}
             |
             Expr:exp1
             {:
                 RESULT = parser.condFactCheck(exp1, exp1left);
             :};

Expr ::= Term_list:tl
         {:
             RESULT = tl;
         :}
         |
         MINUS Term_list:tl
         {:
             RESULT = parser.minusTerm(tl, tlleft);
             Code.put(Code.neg);
         :};

Term_list ::= Term_list:t Addop:op Term:r
              {:
                   Code.put(op);
                   RESULT = parser.addopTerms(t, r, rleft, op);
              :}
              |
              Term:trm
              {:
                   RESULT = trm;
              :};

Term ::= Factor_list:fl
         {:
             RESULT = fl;
         :};

Factor_list ::= Factor_list:fl Mulop:op Factor:ff
                {:
                    Code.put(op);
                    RESULT = parser.mulopFactors(fl, ff, flleft);
                :}
                |
                Factor:f
                {:
                    RESULT = f;
                :};

Factor ::= NUMBER:n
           {:
              Obj num = Tab.insert(Obj.Con, "NUMBER", Tab.intType);
              num.setAdr(n.intValue());
              Code.load(num);

              RESULT = Tab.intType;
           :}
           |
           CHARCONST:c
           {:
               Obj ch = Tab.insert(Obj.Con, "CHAR_CONST", Tab.charType);
               ch.setAdr(c.charValue());
               Code.load(ch);

               RESULT = Tab.charType;
           :}
           |
           LPAREN Expr:e RPAREN
           {:
               RESULT = e;
           :}
           |
           BOOLVAL:b
           {:
               Obj bul = Tab.insert(Obj.Con, "BOOL", TabUtils.boolType);
               bul.setAdr((b == true) ? 1 : 0);
               Code.load(bul);

               RESULT = TabUtils.boolType;
           :}
           |
           STRING_LITERAL:stl
           {:
               RESULT = TabUtils.stringType;
           :}
           |
           NEW Type:id LSQUARE Expr:e RSQUARE
           {:
               RESULT = parser.getRefArray(id, e, eleft);

               Code.put(Code.newarray);

               if (Tab.charType.equals(id)) {
                    Code.put(0);
               } else {
                    Code.put(1);
               }
           :}
           |
           NEW Type:id
           {:
               parser.objectCreationCount++;
               RESULT =  parser.newTypeStat(id, idleft);
           :}
           |
           Designator:d
           {:
               Code.load(d);

               if(d.getType() == null) {

                    RESULT = Tab.noType;
               } else {

                    RESULT = d.getType();
               }
           :}
           |
           LEN LPAREN Expr:e RPAREN SEMI
           {:
          		parser.checkLenFunc(e, eleft);
           :}
           |
           ProgramFunc:func ActualPars_Rparen_Recovery:ap
           {:
               RESULT = parser.checkFunc(func, funcleft, scope);
           :};

ActualPars_Rparen_Recovery ::= ActualPars RPAREN:lt
                               {:

                               :}
                               |
                               error RPAREN:l
                               {:
                                  parser.report_error(SintaxErrorDesc.S1_14.print(lleft), null);
                               :};

ActualPars ::= ActualParamList
			   |
			   /* epsilon */  ;

ActualParamList ::= ActualParamList COMMA Expr:e
                    {:
                       TabUtils.actualParams.add(e);
                       // TODO
                       // Code.put(Code.pop); // stvarni parametri nisu implementirani, pa da ne ostanu na steku
                    :}
					|
					Expr:e
					{:
                       TabUtils.actualParams.add(e);
                       // TODO
                       //Code.put(Code.pop); // stvarni parametri nisu implementirani, pa da ne ostanu na steku
					:};

Designator ::= IDENT:name
                {:
                    TabUtils.currentDesignatorObj = parser.getDesignator(name, nameleft, scope);

                    Code.load(TabUtils.currentDesignatorObj);
                :}
                DesignatorList:dsList
                {:
                    RESULT = dsList;

                    TabUtils.currentDesignatorObj = Tab.noObj;
                :}
                |
                IDENT:name
                {:
                    RESULT = parser.getDesignator(name, nameleft, scope);
                :};

DesignatorList ::= DesignatorList DesignatorPart:dlp
                   {:
                        RESULT = dlp;
                   :}
                   |
                   DesignatorPart:dp
                   {:
                        RESULT = dp;
                   :};

DesignatorPart ::=  ExprInSquaresRS_Recovery:exSqr
                    {:
                        if(TabUtils.currentDesignatorObj.getType().getKind() != Struct.Array) {

                            parser.report_error(SemanticErrorDesc.S2_44.print(exSqrleft), null);
                            RESULT = Tab.noObj;
                        } else {

                            RESULT = new Obj(Obj.Elem, "Elem", TabUtils.currentDesignatorObj.getType().getElemType());
                        }
                    :}
                    |
                    DOT IDENT:name
                    {:
						RESULT = parser.getClassDesignator(name, nameleft);
                    :};  
                    
ExprInSquaresRS_Recovery ::= LSQUARE Expr:e RSQUARE
                             {:
                                  if(!Tab.intType.equals(e)) {
                                    parser.report_error(SemanticErrorDesc.S2_43.print(eleft), null);
                                  }
                             :}
                             |
                             error RSQUARE:l
                             {:
                                parser.report_error(SintaxErrorDesc.S1_15.print(lleft), null);
                             :};
                    
Addop ::= PLUS {: RESULT = Code.add; :}
          |
          MINUS {: RESULT = Code.sub; :};

Mulop ::= TIMES {: RESULT = Code.mul; :}
          |
          DIV {: RESULT = Code.div; :}
          |
          MOD {: RESULT = Code.rem; :};

Relop ::= ISEQUAL {: RESULT = Code.eq; :}
          |
          ISNOTEQUAL {: RESULT = Code.ne; :}
          |
          ISGREATER {: RESULT = Code.gt; :}
          |
          ISGREATEREQ {: RESULT = Code.ge; :}
          |
          ISLESS {: RESULT = Code.lt; :}
          |
          ISLESSEQ {: RESULT = Code.le; :};

